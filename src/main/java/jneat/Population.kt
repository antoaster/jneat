/* Generated by Together */
package jneat

import jNeatCommon.*
import java.text.DecimalFormat
import java.util.*

/**
 * A Population is a group of Organisms including their species
 */
class Population : Neat {

    val organisms = mutableListOf<Organism>()
    val species = mutableListOf<Species>()

    /**
     * For holding the genetic innovations of the newest generation
     */
    @JvmField
    var innovations: MutableList<Innovation> = ArrayList()

    /**
     * Current label number available for nodes
     */
    var cur_node_id = 0
        private set

    /**
     * Current  number of innovation
     */
    var cur_innov_num = 0.0
        private set

    /**
     * The highest species number
     */
    var last_species = 0

    /**
     * The last generation played
     */
    var final_gen = 0
    //Fitness Statistics
    /**
     * the mean of fitness in current epoch
     */
    var mean_fitness = 0.0

    /**
     * current variance in this epoch
     */
    var variance = 0.0

    /**
     * Is a current standard deviation in current epoch
     */
    var standard_deviation = 0.0

    /**
     * An integer that when above zero tells when the first winner appeared; the number is epoch number.
     */
    var winnergen = 0

    /**
     * maximum fitness. (is used for delta code and stagnation detection)
     */
    var highest_fitness = 0.0

    /**
     * If  too high, leads to delta coding process.
     */
    var highest_last_changed = 0

    fun getInnovations(): List<Innovation> {
        return innovations
    }

    constructor(g: Genome, size: Int) {
        winnergen = 0
        highest_fitness = 0.0
        highest_last_changed = 0
        spawn(g, size)
    }

    fun spawn(g: Genome, size: Int) {
        var count: Int
        var newgenome: Genome? = null
        var neworganism: Organism
        organisms.clear()
        count = 1
        while (count <= size) {

            //	  System.out.print("\n Creating organism -> " + count);
            newgenome = g.duplicate(count)
            newgenome.mutate_link_weight(1.0, 1.0, NeatConstant.GAUSSIAN)
            neworganism = Organism(0.0, newgenome, 1)
            organisms.add(neworganism)
            count++
        }

        //Keep a record of the innovation and node number we are on
        cur_node_id = newgenome!!.get_last_node_id()
        cur_innov_num = newgenome.get_last_gene_innovnum()

        //Separate the new Population into species
        speciate()
    }

    /**
     * epoch turns over a Population to
     * the next generation based on fitness
     */
    fun epoch(generation: Int) {
        var itr_specie: Iterator<Species?>
        var itr_organism: Iterator<Organism>
        var total = 0.0
        var orgcount = 0
        var max_expected: Int
        var total_expected: Int //precision checking
        var final_expected: Int
        var half_pop = 0
        var overall_average = 0.0
        var total_organisms = 0
        var skim = 0.0
        var tmpi = 0
        var best_species_num = 0
        var stolen_babies = 0
        var size_of_curr_specie = 0
        val NUM_STOLEN = p_babies_stolen //Number of babies to steal
        // al momento NUM_STOLEN=1
        var _specie: Species? = null
        var curspecies: Species? = null
        var best_specie: Species? = null


        // Use Species' ages to modify the objective fitness of organisms
        // in other words, make it more fair for younger species
        // so they have a chance to take hold
        // Also penalize stagnant species
        // Then adjust the fitness using the species size to "share" fitness
        // within a species.
        // Then, within each Species, mark for death
        // those below survival_thresh * average
        itr_specie = species!!.iterator()
        while (itr_specie.hasNext()) {
            _specie = itr_specie.next()
            _specie!!.adjust_fitness()
        }

        //Go through the organisms and add up their fitnesses to compute the
        //overall average
        itr_organism = organisms!!.iterator()
        total = 0.0
        while (itr_organism.hasNext()) {
            total += itr_organism.next().fitness
        }
        total_organisms = organisms!!.size
        overall_average = total / total_organisms

        //Now compute expected number of offspring for each individual organism
        //
        itr_organism = organisms!!.iterator()
        val orgnum = 0
        while (itr_organism.hasNext()) {
            val _organism = itr_organism.next()
            _organism.expected_offspring = _organism.fitness / overall_average
        }

        //Now add those offspring up within each Species to get the number of
        //offspring per Species
        skim = 0.0
        total_expected = 0
        val specount = 0
        itr_specie = species!!.iterator()
        while (itr_specie.hasNext()) {
            _specie = itr_specie.next()
            skim = _specie!!.count_offspring(skim)
            total_expected += _specie.expected_offspring
        }

        //Need to make up for lost foating point precision in offspring assignment
        //If we lost precision, give an extra baby to the best Species
        if (total_expected < total_organisms) {

            //Find the Species expecting the most
            max_expected = 0
            final_expected = 0
            itr_specie = species!!.iterator()
            while (itr_specie.hasNext()) {
                _specie = itr_specie.next()
                if (_specie!!.expected_offspring >= max_expected) {
                    max_expected = _specie.expected_offspring
                    best_specie = _specie
                }
                final_expected += _specie.expected_offspring
            }
            //Give the extra offspring to the best species
            best_specie!!.expected_offspring++
            final_expected++

            //If we still arent at total, there is a problem
            //Note that this can happen if a stagnant Species
            //dominates the population and then gets killed off by its age
            //Then the whole population plummets in fitness
            //If the average fitness is allowed to hit 0, then we no longer have
            //an average we can use to assign offspring.
            if (final_expected < total_organisms) {
                print("\n Sorry : Population .has DIED +")
                print("\n ------------------------------")
                itr_specie = species!!.iterator()
                while (itr_specie.hasNext()) {
                    _specie = itr_specie.next()
                    _specie!!.expected_offspring = 0
                }
                best_specie.expected_offspring = total_organisms
            }
        }
        // TODO: this is a mess
        val sorted_species = (species as List<Species>).sortedBy { it.organisms.first().orig_fitness }.reversed()

        // sorted species has all species ordered : the species with orig_fitness maximum is first
        curspecies = sorted_species[0]
        best_species_num = curspecies!!.id
        var rep1 = StringBuffer()
        //   	System.out.print("\n  The BEST specie is #" + best_species_num);
        rep1.append("\n  the BEST  specie is #$best_species_num")


        // report current situation
        itr_specie = sorted_species.iterator()
        while (itr_specie.hasNext()) {
            _specie = itr_specie.next()
            //	  	System.out.print("\n  orig fitness of Species #" + _specie.id);
            rep1.append("""
  orig fitness of Species #${_specie!!.id}""")

            //	  	System.out.print(" (Size " + _specie.getOrganisms().size() + "): ");
            rep1.append(" (Size " + _specie.getOrganisms().size + "): ")

            // 	  	System.out.print(" is " + ((Organism) (_specie.organisms.get(0)).orig_fitness);
            rep1.append(" is " + _specie.organisms[0].orig_fitness)

            // 	  	System.out.print(" last improved ");
            rep1.append(" last improved ")

            //	  	System.out.print(_specie.age - _specie.age_of_last_improvement);
            rep1.append(_specie.age - _specie.age_of_last_improvement)

            //	  	System.out.print(" offspring "+_specie.expected_offspring);
            rep1.append(" offspring " + _specie.expected_offspring)
        }
        EnvConstant.REPORT_SPECIES_TESTA = rep1.toString()
        rep1 = StringBuffer()
        curspecies = sorted_species[0]

        //Check for Population-level stagnation
        curspecies!!.getOrganisms()[0].pop_champ = true
        val tmp = curspecies.getOrganisms()[0]
        if (curspecies.organisms[0].orig_fitness > highest_fitness) {
            highest_fitness = curspecies.organisms[0].orig_fitness
            highest_last_changed = 0
            //	  	System.out.print("\n    Good! Population has reached a new *RECORD FITNESS* -> " + highest_fitness);
            rep1.append("\n    population has reached a new *RECORD FITNESS* -> $highest_fitness")


            // 01.06.2002
            EnvConstant.CURR_ORGANISM_CHAMPION = tmp
            EnvConstant.MIN_ERROR = curspecies.organisms[0].error
        } else {
            ++highest_last_changed
            EnvConstant.REPORT_SPECIES_TESTA = ""

            //	  	System.out.print("\n  Are passed "+ highest_last_changed+ " generations from last population fitness record: "+ highest_fitness);
            rep1.append("\n    are passed $highest_last_changed generations from last population fitness record: $highest_fitness")
        }
        EnvConstant.REPORT_SPECIES_CORPO = rep1.toString()

        //Check for stagnation- if there is stagnation, perform delta-coding
        if (highest_last_changed >= p_dropoff_age + 5) {
            //------------------ block delta coding ----------------------------
            print("\n+  <PERFORMING DELTA CODING>")
            highest_last_changed = 0
            half_pop = p_pop_size / 2
            tmpi = p_pop_size - half_pop
            print("""
  Pop size is $p_pop_size""")
            print(", half_pop=$half_pop,   pop_size - halfpop=$tmpi")
            itr_specie = sorted_species.iterator()
            _specie = itr_specie.next()

            // the first organism of first species can have  offspring = 1/2 pop size
            _specie!!.organisms[0].super_champ_offspring = half_pop
            // the first species  can have offspring = 1/2 pop size
            _specie.expected_offspring = half_pop
            _specie.age_of_last_improvement = _specie.age
            if (itr_specie.hasNext()) {
                _specie = itr_specie.next()
                _specie!!.organisms[0].super_champ_offspring = half_pop
                // the second species  can have offspring = 1/2 pop size
                _specie.expected_offspring = half_pop
                _specie.age_of_last_improvement = _specie.age
                // at this moment the offpring is terminated : the remainder species has 0 offspring!
                while (itr_specie.hasNext()) {
                    _specie = itr_specie.next()
                    _specie!!.expected_offspring = 0
                }
            } else {
                _specie.organisms[0].super_champ_offspring += p_pop_size - half_pop
                _specie.expected_offspring += p_pop_size - half_pop
            }
        } else {
            // --------------------------------- block baby stolen (if baby stolen > 0)  -------------------------
            //		System.out.print("\n   Starting with NUM_STOLEN = "+NUM_STOLEN);
            if (p_babies_stolen > 0) {
                //Take away a constant number of expected offspring from the worst few species
                var j = sorted_species.size - 1
                while (j >= 0 && stolen_babies < NUM_STOLEN) {
                    _specie = sorted_species[j]
                    //				System.out.print("\n Analisis SPECIE #"+j+" (size = "+_specie.organisms.size()+" )");
                    if (_specie!!.age > 5 && _specie.expected_offspring > 2) {
                        //		System.out.print("\n ....STEALING!");
                        tmpi = NUM_STOLEN - stolen_babies
                        if (_specie.expected_offspring - 1 >= tmpi) {
                            _specie.expected_offspring -= tmpi
                            stolen_babies = NUM_STOLEN
                        } else  //Not enough here to complete the pool of stolen
                        {
                            stolen_babies += _specie.expected_offspring - 1
                            _specie.expected_offspring = 1
                        }
                    }
                    j--
                }


                //		 	System.out.print("\n stolen babies = "+ stolen_babies);
                //Mark the best champions of the top species to be the super champs
                //who will take on the extra offspring for cloning or mutant cloning
                //Determine the exact number that will be given to the top three
                //They get , in order, 1/5 1/5 and 1/10 of the stolen babies
                val tb_four = IntArray(3)
                tb_four[0] = p_babies_stolen / 5
                tb_four[1] = tb_four[0]
                tb_four[2] = p_babies_stolen / 10
                var done = false
                itr_specie = sorted_species.iterator()
                var i_block = 0
                while (!done && itr_specie.hasNext()) {
                    _specie = itr_specie.next()
                    if (_specie!!.last_improved() <= p_dropoff_age) {
                        if (i_block < 3) {
                            if (stolen_babies >= tb_four[i_block]) {
                                _specie.organisms[0].super_champ_offspring = tb_four[i_block]
                                _specie.expected_offspring += tb_four[i_block]
                                stolen_babies -= tb_four[i_block]
                                print("""
  give ${tb_four[i_block]} babies to specie #${_specie.id}""")
                            }
                            i_block++
                        } else {
                            if (NeatRoutine.randfloat() > 0.1) {
                                if (stolen_babies > 3) {
                                    _specie.organisms[0].super_champ_offspring = 3
                                    _specie.expected_offspring += 3
                                    stolen_babies -= 3
                                    print("""
    Give 3 babies to Species ${_specie.id}""")
                                } else {
                                    _specie.organisms[0].super_champ_offspring = stolen_babies
                                    _specie.expected_offspring += stolen_babies
                                    print("""
    Give $stolen_babies babies to Species ${_specie.id}""")
                                    stolen_babies = 0
                                }
                            }
                            if (stolen_babies == 0) done = true
                        }
                    }
                }
                if (stolen_babies > 0) {
                    print("\n Not all given back, giving to best Species")
                    itr_specie = sorted_species.iterator()
                    _specie = itr_specie.next()
                    _specie!!.organisms[0].super_champ_offspring += stolen_babies
                    _specie!!.expected_offspring += stolen_babies
                    print("""
    force +$stolen_babies offspring to Species ${_specie!!.id}""")
                }
            } // end baby_stolen > 0
        }
        // ---------- phase of elimination of organism with flag eliminate ------------
        itr_organism = organisms!!.iterator()
        val vdel: MutableList<Organism> = ArrayList()
        while (itr_organism.hasNext()) {
            val _organism = itr_organism.next()
            if (_organism.eliminate) {
                //Remove the organism from its Species
                _specie = _organism.species
                _specie!!.remove_org(_organism)
                //store the organism can be elimanated;
                vdel.add(_organism)
            }
        }
        //eliminate organism from master list
        organisms!!.removeAll(vdel)
        vdel.clear()


        // ---------- phase of reproduction -----------
        /*   	 System.out.print("\n ---- Reproduction at time " + generation+" ----");
	  System.out.print("\n    species   : "+ sorted_species.size());
	  System.out.print("\n    organisms : "+ organisms.size());
	  System.out.print("\n    cur innov num : "+cur_innov_num);
	  System.out.print("\n    cur node num  : "+cur_node_id);
	  System.out.print("\n ---------------------------------------------");
	  System.out.print("\n Start reproduction of species ....");
	  */itr_specie = sorted_species.iterator()
        // System.out.print("\n verifica");
        //System.out.print("\n this species has "+sorted_species.size()+" elements");
        while (itr_specie.hasNext()) {
            _specie = itr_specie.next()
            _specie!!.reproduce(generation, this, sorted_species)
        }

        //   	System.out.print("\n Reproduction completed");


        //
        //Destroy and remove the old generation from the organisms and species
        // (because we have pointer to organisms , the new organisms created
        //  are not in organisms and can't br eliminated;
        // thus are elimate onlyu corrent organisms !)


        //------prima---------------------------------------
        /*   	
	  	
	  itr_organism = organisms.iterator();
	  vdel = new Vector(organisms.size());
	  
	  while (itr_organism.hasNext()) 
	  {
	  Organism _organism = ((Organism) itr_organism.next());
	  //Remove the organism from its Species
	  _specie = _organism.species;
	  _specie.remove_org(_organism);
	  //store the organism can be elimanated;
	  vdel.add(_organism);
	  }
	  
	  //eliminate organism from master list
	  for (int i = 0; i < vdel.size(); i++) 
	  {
	  Organism _organism = (Organism) vdel.get(i);
	  //	  	organisms.remove(_organism);
	  organisms.removeElement(_organism);
	  }
	  
	  */

        //---------------------------------------------


        //------dopo---------------------------------------
        itr_organism = organisms!!.iterator()
        while (itr_organism.hasNext()) {
            val _organism = itr_organism.next()
            //Remove the organism from its Species
            _specie = _organism.species
            _specie!!.remove_org(_organism)
        }
        organisms!!.clear()

        //Remove all empty Species and age ones that survive
        //As this happens, create master organism list for the new generation
        itr_specie = species!!.iterator()
        val speciesToDelete: MutableList<Species?> = ArrayList()
        orgcount = 0
        while (itr_specie.hasNext()) {
            _specie = itr_specie.next()
            size_of_curr_specie = _specie!!.organisms.size
            if (size_of_curr_specie == 0) speciesToDelete.add(_specie) else {
                //Age any Species that is not newly created in this generation
                if (_specie.novel) _specie.novel = false else _specie.age++
                //from the current species  recostruct thge master list organisms
                for (j in 0 until size_of_curr_specie) {
                    val _organism = _specie.organisms[j]
                    _organism.genome.genome_id = orgcount++
                    //add ugo ******************************************************************************************
                    _organism.genome.phenotype!!.net_id = _organism.genome.genome_id
                    organisms!!.add(_organism)
                }
            }
        }

        // System.out.print("\n the number of species can be eliminated is "+speciesToDelete.size());
        //eliminate species marked from master list
        species!!.removeAll(speciesToDelete)

        //Remove the innovations of the current generation
        innovations.clear()

        /*   	
	  innovations.removeAllElements();
	  innovations.trimToSize();
	  */

        //DEBUG: Check to see if the best species died somehow
        // We don't want this to happen
        itr_specie = species!!.iterator()
        var best_ok = false
        while (itr_specie.hasNext()) {
            _specie = itr_specie.next()
            if (_specie!!.id == best_species_num) {
                best_ok = true
                break
            }
        }


        /*   			
	  if (!best_ok)
	  System.out.print("\n  <ALERT>  THE BEST SPECIES DIED!");
	  else
	  System.out.print("\n  Good : the best Specie #" + best_species_num+" survived ");
	  */if (!best_ok) EnvConstant.REPORT_SPECIES_CODA = "\n  <ALERT>  THE BEST SPECIES DIED!" else EnvConstant.REPORT_SPECIES_CODA = "\n  Good : the best Specie #$best_species_num survived "
        itr_organism = organisms!!.iterator()
        while (itr_organism.hasNext()) {
            val _organism = itr_organism.next()
            if (_organism.pop_champ_child) {
                //		 	System.out.print("\n At end of reproduction cycle, the child of the pop champ is: ");
                break
            }
        }

        //   	System.out.print("\n Epoch complete");
    }

    fun print_to_file_by_species(xNameFile: String?) {
        //
        // write to file genome in native format (for re-read)
        //
        val xFile: IOseq
        xFile = IOseq(xNameFile)
        xFile.IOseqOpenW(false)
        try {
            val itr_specie: Iterator<Species?>
            itr_specie = species!!.iterator()
            while (itr_specie.hasNext()) {
                val _specie = itr_specie.next()
                _specie!!.print_to_file(xFile)
            }
        } catch (e: Throwable) {
            throw RuntimeException(e)
        }
        xFile.IOseqCloseW()
    }

    fun speciate() {
        val itr_organism: Iterator<Organism>
        var itr_specie: Iterator<Species?>
        var compare_org: Organism //Organism for comparison
        var newspecies: Species
        species.clear()
        var counter = 0 //Species counter

        // for each organism.....
        itr_organism = organisms!!.iterator()
        while (itr_organism.hasNext()) {
            val _organism = itr_organism.next()

            // if list species is empty , create the first species!
            if (species.isEmpty()) {
                newspecies = Species(++counter) // create a new specie
                species.add(newspecies) // add this species to list of species
                newspecies.add_Organism(_organism)
                // Add to new spoecies the current organism
                _organism.species = newspecies // Point organism to its species
            } else {
                // looop in all species.... (each species is a Vector of organism...)
                itr_specie = species.iterator()
                var done = false
                while (!done && itr_specie.hasNext()) {

                    // point _species-esima
                    val _specie = itr_specie.next()
                    // point to first organism of this _specie-esima
                    compare_org = _specie!!.getOrganisms()[0]
                    // compare _organism-esimo('_organism') with first organism in current specie('compare_org')
                    val curr_compat: Double = _organism.genome.compatibility(compare_org.genome)
                    if (curr_compat < p_compat_threshold) {
                        //Found compatible species, so add this organism to it
                        _specie.add_Organism(_organism)
                        //update in organism pointer to its species
                        _organism.species = _specie
                        //force exit from this block ...
                        done = true
                    }
                }

                // if no found species compatible , create specie
                if (!done) {
                    newspecies = Species(++counter) // create a new specie
                    species.add(newspecies) // add this species to list of species
                    newspecies.add_Organism(_organism)
                    // Add to new species the current organism
                    _organism.species = newspecies // Point organism to its species
                }
            }
        }
        last_species = counter //Keep track of highest species
    }

    /**
     * the increment of cur_node_id must be
     * executed only from a method of population
     * for security reason
     */
    val cur_node_id_and_increment: Int
        get() = cur_node_id++

    /**
     * the increment of cur_innov_num must be
     * executed only from a method of population
     * for security reason
     */
    val curr_innov_num_and_increment: Double
        get() = cur_innov_num++

    /**
     * Insert the method's description here.
     * Creation date: (01/02/2002 9.48.44)
     */
    constructor() {}

    /**
     * Special constructor to create a population of random
     * topologies uses
     * Genome (int i, int o, int n,int nmax, bool r, double linkprob)
     * See the Genome constructor for the argument specifications
     * the parameter are :
     * size = number of organisms
     * i    = number of inputs
     * o    = number of output
     * nmax = max index of nodes
     * r    = the net can be recurrent ?
     * linkprob = probability of connecting two nodes.
     */
    constructor(size: Int, i: Int, o: Int, nmax: Int, r: Boolean, linkprob: Double) {
        val mask4 = "0000"
        val fmt4 = DecimalFormat(mask4)
        var fname: String
        var count: Int
        var new_genome: Genome? = null

//		 System.out.print("\n  -Making a random population of "+size+" organisms ");
        winnergen = 0
        highest_fitness = 0.0
        highest_last_changed = 0
        organisms.clear()
        var fname_prefix = EnvRoutine.getJneatFileData(EnvConstant.PREFIX_GENOME_RANDOM)
        count = 0
        while (count < size) {
            new_genome = Genome(count, i, o, NeatRoutine.randint(0, nmax), nmax, r, linkprob)

            // backup genome primordial
            fname = fname_prefix + fmt4.format(count.toLong())
            new_genome.print_to_filename(fname)
            organisms.add(Organism(0.0, new_genome, 1))
            count++
        }
        cur_node_id = i + o + nmax + 1
        cur_innov_num = (i + o + nmax) * (i + o + nmax) + 1.toDouble()

//		 System.out.print("\n  The first  node_id  available is "+cur_node_id);
//		 System.out.print("\n  The first innov_num available is "+cur_innov_num);
        speciate()

        // backup of population
        fname_prefix = EnvRoutine.getJneatFileData(EnvConstant.NAME_CURR_POPULATION)
        print_to_filename(fname_prefix)
    }

    /**
     * Construct off of a file of Genomes
     */
    constructor(xFileName: String) {
        val xFile: IOseq
        var curword: String
        var idcheck = 0
        var new_genome: Genome
        organisms.clear()
        winnergen = 0
        highest_fitness = 0.0
        highest_last_changed = 0
        cur_node_id = 0
        cur_innov_num = 0.0
        xFile = IOseq(xFileName)
        val ret = xFile.IOseqOpenR()
        if (ret) {
            val tmp1 = StringBuffer("")
            val tmp2 = StringBuffer("")
            var status = 0
            try {

                //   System.out.println("  ..opened population file "+xFileName);
                var xline = xFile.IOseqRead()
                while (xline != "EOF") {
                    val st = StringTokenizer(xline)
                    curword = st.nextToken()
                    if (curword.equals("genomestart", ignoreCase = true)) {
                        if (status == 1) status = 2
                        curword = st.nextToken()
                        idcheck = curword.toInt()
                        new_genome = Genome(idcheck, xFile)
                        new_genome.notes = tmp2.toString()
                        organisms.add(Organism(0.0, new_genome, 1))
                        if (cur_node_id < new_genome.get_last_node_id()) cur_node_id = new_genome.get_last_node_id()
                        if (cur_innov_num < new_genome.get_last_gene_innovnum()) cur_innov_num = new_genome.get_last_gene_innovnum()
                    } else if (curword == "/*") {
                        if (status == 0) status = 1
                        if (status == 2) {
                            status = 1
                            //		tmp2 = new StringBuffer("");
                        }
                        curword = st.nextToken()
                        //	 tmp1 = new StringBuffer("");
                        while (curword != "*/") {
                            //				tmp1.append(" "+curword);
                            //			 			  		System.out.print(" " + curword);
                            curword = st.nextToken()
                        }
                        //				  				System.out.print("\n");
                        /*	 tmp2.append(" "+tmp1);
				  	System.out.print("\n tmp2 = "+tmp2);*/
                    }
                    xline = xFile.IOseqRead()
                }
            } catch (e: Throwable) {
                System.err.println("$e : error during read $xFileName")
            }
            xFile.IOseqCloseR()
            //System.out.println("\n  ok readed!");
            speciate()
        }
    }

    fun print_to_filename(xNameFile: String?) {
        //
        // write to file genome in native format (for re-read)
        //
        val xFile: IOseq
        xFile = IOseq(xNameFile)
        xFile.IOseqOpenW(false)
        try {
            print_to_file(xFile)
        } catch (e: Throwable) {
            System.err.println(e)
        }
        xFile.IOseqCloseW()
    }

    /**
     * Debug Population
     * Note: This checks each genome by verifying each one
     * Only useful for debugging
     */
    fun verify() {
        val itr_organism: Iterator<Organism>
        var _organism: Organism? = null
        itr_organism = organisms!!.iterator()
        while (itr_organism.hasNext()) {
            _organism = itr_organism.next()
            _organism.genome.verify()
        }
    }

    fun print_to_file(xFile: IOseq?) {
        //
        // write to file genome in native format (for re-read)
        //
        val itr_organism: Iterator<Organism>
        var _organism: Organism? = null
        itr_organism = organisms!!.iterator()
        while (itr_organism.hasNext()) {
            _organism = itr_organism.next()
            _organism.genome.print_to_file(xFile!!)
        }
    }

    /**
     * Construct off of a file of Genomes
     */
    constructor(xFileName: String, _mamaMiaWhatAreYouDoinga: Boolean) {
        var xok = false
        var curword: String
        var idcheck = 0
        var new_genome: Genome
        organisms.clear()
        winnergen = 0
        highest_fitness = 0.0
        highest_last_changed = 0
        cur_node_id = 0
        cur_innov_num = 0.0
        val xFile = IOseq(xFileName)
        val ret = xFile.IOseqOpenR()
        if (ret) {
            var status = 0
            try {
                println("  ..opened population file $xFileName")
                var xline = xFile.IOseqRead()
                while (xline != "EOF") {
                    val st = StringTokenizer(xline)
                    curword = st.nextToken()
                    if (curword.equals("genomestart", ignoreCase = true)) {
                        if (status == 1) status = 2
                        curword = st.nextToken()
                        idcheck = curword.toInt()
                        new_genome = Genome(idcheck, xFile)
                        new_genome.notes = ""
                        if (xok) organisms.add(Organism(0.0, new_genome, 1))
                        xok = false
                        if (cur_node_id < new_genome.get_last_node_id()) cur_node_id = new_genome.get_last_node_id()
                        if (cur_innov_num < new_genome.get_last_gene_innovnum()) cur_innov_num = new_genome.get_last_gene_innovnum()
                    } else if (curword == "/*") {
                        if (xline.contains("WINNER")) {
                            //	                System.out.print("\n found a winner genome" + xline);
                            xok = true
                        }
                        if (status == 0) status = 1
                        if (status == 2) {
                            status = 1
                            //						tmp2 = new StringBuffer("");
                        }


//					 System.out.print("\n passo de qui");
                        curword = st.nextToken()
                        //			 tmp1 = new StringBuffer("");
                        while (curword != "*/") {
                            //		tmp1.append(" "+curword);
                            //		 			  		System.out.print(" " + curword);
                            curword = st.nextToken()
                        }
                        /* 				System.out.print("\n");
					 tmp2.append(" "+tmp1);
				  	System.out.print("\n tmp2 = "+tmp2);*/
                    }
                    xline = xFile.IOseqRead()
                }
            } catch (e: Throwable) {
                System.err.println("$e : error during read $xFileName")
            }
            xFile.IOseqCloseR()
            println("\n  ok readed!")
            speciate()
        }
    }
}