/* Generated by Together */
package jneat

import jNeatCommon.IOseq
import jNeatCommon.NeatConstant
import java.text.DecimalFormat
import java.util.*

/**
 * A NODE is either a NEURON or a SENSOR. If it's a sensor, it can be loaded with a value for output
 * If it's a neuron, it has a list of its incoming input signals Use an activation count to avoid flushing
 */
class NNode {
    /**
     * type is either SIGMOID ..or others that can be added
     */
    var ftype: Int

    /**
     * type is either NEURON or SENSOR
     */
    var type: Int

    /**
     * The incoming activity before being processed
     */
    var activesum: Double

    /**
     * The total activation entering in this Node
     */
    var activation: Double

    /**
     * when are signal's  to node,  the node switch this field  from FALSE to  TRUE
     */
    var active_flag: Boolean

    /**
     * not used
     */
    var output: Double

    /**
     * vector of real values for hebbian or other advanced function future
     */
    var params = DoubleArray(Neat.p_num_trait_params)

    /**
     * A list of pointers to incoming weighted signals from other nodes
     */
    val incoming = mutableListOf<Link>()

    /**
     * A list of pointers to links carrying this node's signal
     */
    var outgoing = mutableListOf<Link>()
    /**
     * Numeric identification of node
     */
    var node_id: Int

    /**
     * Used for genetic marking of nodes. are 4  type of node : input,bias,hidden,output
     */
    var gen_node_label: Int

    /**
     * this value is how many time this node are activated during activation of network
     */
    var activation_count: Double

    /**
     * activation value of node at time t-1; Holds the previous step's activation for recurrency
     */
    var last_activation: Double

    /**
     * activation value of node at time t-2 Holds the activation before  the previous step's
     */
    var last_activation2: Double

    /**
     * Points to a trait of parameters
     */
    var nodetrait: Trait?

    /**
     * Is a reference  to a  Node ; Has used for generate and point from a genetic node (genotype)  to a real node (fenotype)
     * during 'genesis' process
     *
     * @clientCardinality 1
     * @supplierCardinality 1
     */
    var analogue: NNode?

    /**
     * Is a  temporary reference  to a  Node ; Has used for generate a new genome during duplicate phase of genotype.
     *
     * @supplierCardinality 1
     * @clientCardinality 1
     */
    var dup: NNode?
    fun setActivesum(activesum: Int) {
        this.activesum = activesum.toDouble()
    }

    constructor(ntype: Int, nodeid: Int) {
        active_flag = false
        activesum = 0.0
        activation = 0.0
        output = 0.0
        last_activation = 0.0
        last_activation2 = 0.0
        type = ntype //NEURON or SENSOR type
        activation_count = 0.0 //Inactive upon creation
        node_id = nodeid // id del nodo
        ftype = NeatConstant.SIGMOID // funt act : signmoide
        gen_node_label = NeatConstant.HIDDEN
        nodetrait = null
        //	  incoming = new Vector(1, 0);
        //	  outgoing = new Vector(1, 0);
        dup = null
        analogue = null
        is_traversed = false
        inner_level = 0
    }

    constructor(ntype: Int, nodeid: Int, placement: Int) {
        active_flag = false
        activesum = 0.0
        activation = 0.0
        output = 0.0
        last_activation = 0.0
        last_activation2 = 0.0
        type = ntype //NEURON or SENSOR type
        activation_count = 0.0 //Inactive upon creation
        node_id = nodeid // id del nodo
        ftype = NeatConstant.SIGMOID // funt act : signmoide
        gen_node_label = placement
        nodetrait = null
        //	  incoming = new Vector(1, 0);
        //	  outgoing = new Vector(1, 0);
        dup = null
        analogue = null
        is_traversed = false
        inner_level = 0
    } //

    //      Construct the node out of a file specification
    //      using given list of traits
    //
    constructor(xline: String?, traits: List<Trait>) {
        active_flag = false
        inner_level = 0
        activesum = 0.0
        activation = 0.0
        output = 0.0
        last_activation = 0.0
        last_activation2 = 0.0
        activation_count = 0.0 //Inactive upon creation
        ftype = NeatConstant.SIGMOID // funt act : signmoide
        //  incoming = new Vector(1, 0);
        //  outgoing = new Vector(1, 0);
        dup = null
        analogue = null
        val itr_trait: Iterator<*>
        val _trait_id: Int
        val st: StringTokenizer
        var s1: String
        st = StringTokenizer(xline)

        //skip keyword
        s1 = st.nextToken()

        //Get the node parameters
        s1 = st.nextToken()
        node_id = s1.toInt()

        //get trait
        s1 = st.nextToken()
        _trait_id = s1.toInt()

        //get type of node
        s1 = st.nextToken()
        type = s1.toInt()

        //get genetic typw of node
        s1 = st.nextToken()
        gen_node_label = s1.toInt()
        nodetrait = null
        is_traversed = false
        if (_trait_id > 0 && traits != null) {
            itr_trait = traits.iterator()
            while (itr_trait.hasNext()) {
                val _trait = itr_trait.next() as Trait
                if (_trait.trait_id == _trait_id) {
                    nodetrait = _trait
                    break
                }
            }
        }
    }

    constructor(n: NNode, t: Trait?) {
        active_flag = false
        activesum = 0.0
        activation = 0.0
        output = 0.0
        last_activation = 0.0
        last_activation2 = 0.0
        type = n.type //NEURON or SENSOR type
        activation_count = 0.0 //Inactive upon creation
        node_id = n.node_id // id del nodo
        ftype = NeatConstant.SIGMOID // funt act : sigmoid
        gen_node_label = n.gen_node_label
        nodetrait = t
        dup = null
        analogue = null
        is_traversed = false
        inner_level = 0
    }

    fun derive_trait(t: Trait?) {
        if (t != null) {
            for (count in 0 until Neat.p_num_trait_params) params[count] = t.params[count]
        } else {
            for (count in 0 until Neat.p_num_trait_params) params[count] = 0.0
        }
    }

    /**
     *
     */
    fun depth(xlevel: Int, mynet: Network?, xmax_level: Int): Int {
        var xlevel = xlevel
        var xmax_level = xmax_level
        val itr_link: Iterator<*>
        val cost1: StringBuffer? = null
        val cost2: String? = null


        // control for loop
        if (xlevel > 100) {
            print("\n ** DEPTH NOT DETERMINED FOR NETWORK WITH LOOP ")
            //	  	System.out.print("\n Fenotype is " + mynet.getNet_id());
            //	  	System.out.print("\n Genotype is  " + mynet.getNet_id());
            //	  	mynet.genotype.op_view();
            return 10
        }

        //Base Case
        if (type == NeatConstant.SENSOR) return xlevel
        xlevel++

        // recursion case
        itr_link = incoming.iterator()
        var cur_depth = 0 //The depth of the current node
        while (itr_link.hasNext()) {
            val _link = itr_link.next() as Link
            val _ynode = _link.in_node
            if (!_ynode.is_traversed) {
                _ynode.is_traversed = true
                cur_depth = _ynode.depth(xlevel, mynet, xmax_level)
                _ynode.inner_level = cur_depth - xlevel
            } else cur_depth = xlevel + _ynode.inner_level
            if (cur_depth > xmax_level) xmax_level = cur_depth
        }
        return xmax_level
    }

    fun get_active_out(): Double {
        return if (activation_count > 0) activation else 0.0
    }

    fun op_view() {
        val maskf = " #,##0"
        val fmtf = DecimalFormat(maskf)
        val mask5 = " #,##0.000"
        val fmt5 = DecimalFormat(mask5)
        if (type == NeatConstant.SENSOR) print("\n (Sensor)")
        if (type == NeatConstant.NEURON) print("\n (Neuron)")
        print(
                fmtf.format(node_id.toLong())
                        + " activation count "
                        + fmt5.format(activation_count)
                        + " activation="
                        + fmt5.format(activation)
                        + ")")
    }

    fun sensor_load(value: Double): Boolean {
        return if (type == NeatConstant.SENSOR) {
            //Time delay memory
            last_activation2 = last_activation
            last_activation = activation
            activation_count++ //Puts sensor into next time-step
            activation = value //ovviamente non viene applicata la f(x)!!!!
            true
        } else false
    }

    var inner_level: Int
    var is_traversed: Boolean

    /**
     * .
     */
    fun mark(xlevel: Int, mynet: Network?): Boolean {
        val itr_link: Iterator<*>

        // loop control
        if (xlevel > 100) {
            //      System.out.print("\n ** DEPTH NOT DETERMINED FOR NETWORK WITH LOOP ");
            //      System.out.print("\n Network name is " + mynet.getNet_id());
            //      mynet.genotype.op_view();
            return false
        }

        // base Case
        if (type == NeatConstant.SENSOR) {
            is_traversed = true
            return true
        }


        // recurrency case
        itr_link = incoming.iterator()
        var rc = false
        while (itr_link.hasNext()) {
            val _link = itr_link.next() as Link
            if (!_link.in_node.is_traversed) {
                _link.in_node.is_traversed = true
                rc = _link.in_node.mark(xlevel + 1, mynet)
                if (rc == false) return false
            }
        }
        return true
    }

    fun print_to_file(xFile: IOseq) {
        val s2 = StringBuffer("")
        s2.append("node ")
        s2.append(node_id)
        if (nodetrait != null) s2.append(" " + nodetrait!!.trait_id) else s2.append(" 0")
        s2.append(" $type")
        s2.append(" $gen_node_label")
        xFile.IOseqWrite(s2.toString())
    }

    fun flushbackOLD() {
        val itr_link: Iterator<*>

        //A sensor should not flush black
        if (type != NeatConstant.SENSOR) {
            if (activation_count > 0) {
                activation_count = 0.0
                activation = 0.0
                last_activation = 0.0
                last_activation2 = 0.0
            }
            //Flush back recursively
            itr_link = incoming.iterator()
            while (itr_link.hasNext()) {
                val _link = itr_link.next() as Link
                _link.added_weight = 0.0
                _link.is_traversed = false
                if (_link.in_node.activation_count > 0) _link.in_node.flushbackOLD()
            }
        } else {
            //Flush the SENSOR
            activation_count = 0.0
            activation = 0.0
            last_activation = 0.0
            last_activation2 = 0.0
        }
    }

    fun resetNNode() {
        var itr_link: Iterator<*>
        activation_count = 0.0
        activation = 0.0
        last_activation = 0.0
        last_activation2 = 0.0

        //Flush back link
        itr_link = incoming.iterator()
        while (itr_link.hasNext()) {
            val _link = itr_link.next() as Link
            _link.added_weight = 0.0
            _link.is_traversed = false
        }

        //Flush forw link
        itr_link = outgoing.iterator()
        while (itr_link.hasNext()) {
            val _link = itr_link.next() as Link
            _link.added_weight = 0.0
            _link.is_traversed = false
        }
    }
}