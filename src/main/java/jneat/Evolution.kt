/* Generated by Together */
package jneat

import jNeatCommon.IOseq
import jNeatCommon.NeatConstant
import java.text.DecimalFormat
import java.util.*

object Evolution {
    /**
     * this is a standard experiment for XOR
     * emulation;
     * is passed a name of a started genome
     * and a number of times can be execute
     * this experiment;
     */
    fun Experiment1(xFileName: String, gens: Int) {
        val fname_prefix = "c:\\jneat\\dati\\population.natural"
        var pop: Population? = null
        val st: StringTokenizer
        var curword: String
        val xline: String
        var fnamebuf: String
        var gen: Int
        val xFile: IOseq
        val id: Int
        var expcount = 0
        val mask6 = "000000"
        val fmt6 = DecimalFormat(mask6)
        println("------ Start experiment 1 -------")
        xFile = IOseq(xFileName)
        val ret = xFile.IOseqOpenR()
        if (ret) {
            try {
                println(" Start XOR experiment")
                println("  .read start genome..")
                xline = xFile.IOseqRead()
                st = StringTokenizer(xline)
                //skip
                curword = st.nextToken()
                //id of genome can be readed
                curword = st.nextToken()
                id = curword.toInt()
                println("  .create genome id $id")
                val start_genome = Genome(id, xFile)
                // backup this 'initial' genome (is only for test
                // if the read & write are correct
                start_genome.print_to_filename("c:\\jneat\\dati\\genome.readed")
                expcount = 0
                while (expcount < Neat.p_num_runs) {
                    println(" Spawned population off genome")
                    pop = Population(start_genome, Neat.p_pop_size)
                    print("\n\n Verifying Spawned Pop")
                    pop.verify()
                    print("\n")
                    gen = 1
                    while (gen <= gens) {
                        print("\n---------------- E P O C H  < $gen >--------------")
                        fnamebuf = "g_" + fmt6.format(gen.toLong())
                        val esito = xor_epoch(pop, gen, fnamebuf)
                        gen++
                    }
                    print("""
  Population : innov num   = ${pop.cur_innov_num}""")
                    print("""
             : cur_node_id = ${pop.cur_node_id}""")
                    pop.print_to_filename(fname_prefix)
                    expcount++
                }
            } catch (e: Throwable) {
                System.err.println("$e : error during read $xFileName")
            }
            xFile.IOseqCloseR()
        } else System.err.print("\n : error during open $xFileName")
        println("\n\n End of experiment")
    }

    fun xor_epoch(pop: Population, generation: Int, filename: String): Boolean {
        var esito = false
        //Evaluate each organism if exist the winner.........
        var win = false
        var itr_organism: Iterator<*>
        itr_organism = pop.organisms!!.iterator()
        while (itr_organism.hasNext()) {
            //point to organism
            val _organism = itr_organism.next() as Organism
            //evaluate
            esito = xor_evaluate(_organism)
            // if is a winner , store a flag
            if (esito) win = true
        }

        //compute average and max fitness for each species
        val itr_specie: Iterator<*>
        itr_specie = pop.species!!.iterator()
        while (itr_specie.hasNext()) {
            val _specie = itr_specie.next() as Species
            _specie.compute_average_fitness()
            _specie.compute_max_fitness()
        }
        // Only print to file every print_every generations
        if (win || generation % Neat.p_print_every == 0) pop.print_to_file_by_species("c:\\jneat\\dati\\$filename")


        // if exist a winner write to file
        if (win) {
            var cnt = 0
            itr_organism = pop.organisms.iterator()
            while (itr_organism.hasNext()) {
                val _organism = itr_organism.next()
                if (_organism.winner) {
                    print("""
   -WINNER IS #${_organism.genome.genome_id}""")
                    _organism.genome.print_to_filename("c:\\jneat\\dati\\xor_win$cnt")
                    cnt++
                }
            }
        }
        // wait an epoch and make a reproductionof the best species
        pop.epoch(generation)
        return if (win) {
            print("\t\t** I HAVE FOUND A CHAMPION **")
            true
        } else false
    }

    /**
     * Insert the method's description here.
     * Creation date: (16/01/2002 9.53.37)
     */
    fun xor_evaluate(organism: Organism): Boolean {
        val _net: Network?
        var success = false
        var errorsum = 0.0
        val out = DoubleArray(4) //The four outputs

        //   int numnodes = 0;
        var net_depth = 0 //The max depth of the network to be activated
        var count = 0

        //The four possible input combinations to xor
        //The first number is for biasing
        val `in` = arrayOf(doubleArrayOf(1.0, 0.0, 0.0), doubleArrayOf(1.0, 0.0, 1.0), doubleArrayOf(1.0, 1.0, 0.0), doubleArrayOf(1.0, 1.0, 1.0))
        _net = organism.net
        //   numnodes = organism.genome.nodes.size();
        net_depth = _net.max_depth()


        // for each example , 'count', propagate signal .... and compute results
        count = 0
        while (count <= 3) {


            // first activation from sensor to first next levelof neurons
            _net.load_sensors(`in`[count])
            success = _net.activate()

            // next activation while last level is reached !
            // use depth to ensure relaxation
            for (relax in 0..net_depth) success = _net.activate()

            // ok : the propagation is completed : repeat until all examples are presented
            out[count] = (_net.outputs.first() as NNode).activation
            _net.flush()
            count++
        }


        // control the result
        if (success) {
            errorsum = (Math.abs(out[0]) + Math.abs(1.0 - out[1]) + Math.abs(1.0 - out[2]) + Math.abs(out[3]))
            organism.fitness = Math.pow(4.0 - errorsum, 2.0)
            organism.error = errorsum
        } else {
            errorsum = 999.0
            organism.fitness = 0.001
            organism.error = errorsum
        }
        return if (out[0] < 0.5 && out[1] >= 0.5 && out[2] >= 0.5 && out[3] < 0.5) {
            organism.winner = true
            true
        } else {
            organism.winner = false
            false
        }
    }

    /**
     * This is a test for compute depth of genome and trace
     * all debug information for viewing all signal flowing
     * is not necessary for network simulation
     */
    fun Experiment2(xFileName: String) {
        val st: StringTokenizer
        var curword: String
        val xline: String
        var fnamebuf: String
        val xFile: IOseq
        val id: Int
        var g1: Genome? = null
        println("------ Start experiment 2 -------")
        xFile = IOseq(xFileName)
        val ret = xFile.IOseqOpenR()
        if (ret) {
            try {
                println(" Start experiment 2")
                println(" Read start genome..")
                xline = xFile.IOseqRead()
                st = StringTokenizer(xline)
                //skip
                curword = st.nextToken()
                //id of genome can be readed
                curword = st.nextToken()
                id = curword.toInt()
                g1 = Genome(id, xFile)

                // generate	a link mutation
                g1.mutate_link_weight(Neat.p_weight_mut_power, 1.0, NeatConstant.GAUSSIAN)
                // generate from genome the phenotype
                g1.genesis(id)
                // view genotype
                g1.op_view()

                // assign reference to genotype
                val net = g1.phenotype!!


                // compute first the 'teorical' depth
                val lx = net.max_depth()


                // compute . after, the 'pratical' depth passing
                // the virtual depth;
                val dx = net.is_stabilized(lx)
                // after reset all value of net
                net.flush()
                print("\n For genome : $xFileName : max depth virtuale=$lx")
                print(", max depth reale=$dx")
                if (dx != lx) print("\n  *ALERT*  This net is   NOT   S T A B L E ")
                net.flush()
                val errorsum = 0.0
                val out = DoubleArray(4) //The four outputs
                val numnodes = 0
                val net_depth = 0 //The max depth of the network to be activated
                var count = 0
                var success = false
                val `in` = doubleArrayOf(1.0, 1.0, 1.0)
                count = 0
                // first activation from sensor to first next level of neurons
                net.load_sensors(`in`)

                // first activation....
                success = net.activate()

                // next activation while last level is reached !
                // use depth to ensure relaxation
                for (relax in 1..dx) {
                    success = net.activate()
                    //		  	System.out.print("\n -----TIME <"+relax+"> -----");
                }

                // ok : the propagation is completed
            } catch (e: Throwable) {
                System.err.println("$e : error during open $xFileName")
            }
            xFile.IOseqCloseR()
        } else System.err.print("\n : error during open $xFileName")
        println("\n\n End of experiment")
    }

    /**
     * This is a sample of creating a new Population with
     * 'size_population' organisms , and simulation
     * of XOR example
     * This sample can be started in two modality :
     * -cold : each time the population is re-created from 0;
     * -warm : each time the population re-read last population
     * created and restart from last epoch.
     * (the population backup file is : 'c:\\jneat\\dati\\population.primitive'
     */
    @JvmStatic
    fun Experiment3(size_population: Int, mode: Int, gens: Int) {
        var pop: Population? = null
        val fname_prefix = "c:\\jneat\\dati\\population.primitive"
        var fnamebuf: String
        var gen: Int
        var id: Int
        var expcount = 0
        val mask6 = "000000"
        val fmt6 = DecimalFormat(mask6)
        println("------ Start experiment 3 -------")
        expcount = 0
        while (expcount < Neat.p_num_runs) {
            println(" Spawned population off genome")
            val prb_link = 0.50
            val recurrent = true

            // default cold is : 3 sensor (1 for bias) , 1 out , 5 nodes max, no recurrent
            pop = if (mode == NeatConstant.COLD) Population(size_population, 3, 1, 5, recurrent, prb_link) // cold start-up
            else Population("$fname_prefix.last") // warm start-up
            pop.verify()
            print("\n---------------- Generation starting with----------")
            print("""
  Population : innov num   = ${pop.cur_innov_num}""")
            print("""
             : cur_node_id = ${pop.cur_node_id}""")
            print("\n---------------------------------------------------")
            print("\n")
            gen = 1
            while (gen <= gens) {
                print("\n---------------- Generation ----------------------$gen")
                fnamebuf = "g_" + fmt6.format(gen.toLong())
                val esito = xor_epoch(pop, gen, fnamebuf)
                print("""
  Population : innov num   = ${pop.cur_innov_num}""")
                print("""
             : cur_node_id = ${pop.cur_node_id}""")
                print("\n   result    : $esito")
                gen++
            }
            expcount++
        }

        // backup of population for warm startup
        pop!!.print_to_filename("$fname_prefix.last")
        println("\n\n End of experiment")
    }
    /**
     * Insert the method's description here.
     * Creation date: (16/01/2002 9.46.13)
     */
    /**
     * This is a test for viewing the result of mate
     * or other operation can be executed from two genome
     * the first genome is xFileNameA and second genome is xFileNameB
     */
    fun Experiment4(xFileNameA: String, xFileNameB: String) {
        var st: StringTokenizer
        var curword: String
        var xline: String
        var fnamebuf: String
        var xFile: IOseq
        var id: Int
        var gA: Genome? = null
        var gB: Genome? = null
        println("------ Start experiment 4 -------")
        // read genome A
        //
        xFile = IOseq(xFileNameA)
        var ret = xFile.IOseqOpenR()
        if (ret) {
            try {
                println(" Read genome-A")
                xline = xFile.IOseqRead()
                st = StringTokenizer(xline)
                //skip
                curword = st.nextToken()
                //id of genome can be readed
                curword = st.nextToken()
                id = curword.toInt()
                gA = Genome(id, xFile)
                // view genotype A
            } catch (e: Throwable) {
                System.err.println("$e : error during read $xFileNameA")
            }
            xFile.IOseqCloseR()
        } else System.err.print("\n : error during openA $xFileNameA")


        //
        // read genome B
        //
        xFile = IOseq(xFileNameB)
        ret = xFile.IOseqOpenR()
        if (ret) {
            try {
                println("\n Read genome-B")
                xline = xFile.IOseqRead()
                st = StringTokenizer(xline)
                //skip
                curword = st.nextToken()
                //id of genome can be readed
                curword = st.nextToken()
                id = curword.toInt()
                gB = Genome(id, xFile)
                // view genotype A
            } catch (e: Throwable) {
                System.err.println("$e : error during open $xFileNameB")
            }
            xFile.IOseqCloseR()
        } else System.err.print("\n : error during openB $xFileNameB")


        //   	Genome gC = gA.mate_multipoint(gB,3,0.6,0.3);
        //   	Genome gC = gA.mate_multipoint_avg(gB,3,0.6,0.3);
        println("\n ----genome-A----------")
        gA!!.op_view()
        println("\n ----genome-B----------")
        gB!!.op_view()


        //	gA.DEBUGmate_singlepoint(gB,3);
        println("\n ----genome-RESULT----------")
        val gC = gA.mate_singlepoint(gB, 999)

        // this step is for verify if correct genome
        gC.verify()
        // this step is for verify the phenotype created
        gC.genesis(999)
        // the step print the result genome
        gC.op_view()


        // for viewing the imagine of two genome input and the genome output
        println("\n *******  D I S P L A Y      G R A P H   *********")
        gA.View_mate_singlepoint(gB, 999)
        println("\n *************************************************")
        println("\n\n End of experiment")
    }

    /**
     * This is a test for compute depth of genome and compute
     * if has a path from two nodes (is a test for new version
     * of method  is_recur())  --> has_a_path(..)
     * is not necessary for network simulation
     */
    fun Experiment5(xFileName: String, potin: Int, potout: Int) {
        val st: StringTokenizer
        var curword: String
        val xline: String
        var fnamebuf: String
        val xFile: IOseq
        val id: Int
        var g1: Genome? = null
        var net: Network? = null
        xFile = IOseq(xFileName)
        val ret = xFile.IOseqOpenR()
        if (ret) {
            try {
                println("------ Start experiment 5 -------")
                // read genome A
                println(" Read start genome..")
                xline = xFile.IOseqRead()
                st = StringTokenizer(xline)
                //skip
                curword = st.nextToken()
                //id of genome can be readed
                curword = st.nextToken()
                id = curword.toInt()
                g1 = Genome(id, xFile)

                // generate	a link mutation
                g1.mutate_link_weight(Neat.p_weight_mut_power, 1.0, NeatConstant.GAUSSIAN)
                // generate from genome the phenotype
                g1.genesis(id)

                // view genotype
                g1.op_view()

                // assign reference to genotype
                net = g1.phenotype!!

                // compute first the 'teorical' depth
                val lx = net.max_depth()
                // compute . after, the 'pratical' depth passing
                // the virtual depth;
                val dx = net.is_stabilized(lx)
                print("\n Max depth virtuale=$lx")
                print(", max depth reale=$dx")


                // search the inode
                var inode: NNode? = null
                var onode: NNode? = null
                var curnode: NNode? = null
                var rc = false
                var cnt = 0
                var ix = 0
                while (ix < net.allnodes.size && cnt < 2) {
                    curnode = net.allnodes.elementAt(ix) as NNode
                    if (curnode!!.node_id == potin) {
                        inode = curnode
                        cnt++
                    }
                    if (curnode.node_id == potout) {
                        onode = curnode
                        cnt++
                    }
                    ix++
                }

                // if exist , point to exitsting version
                if (cnt < 2) {
                    print("\n ERROR :nodes in e/o out wrong's : retype!")
                } else {
                    net.status = 0
                    rc = net.has_a_path(inode!!, onode!!, 0, 30)
                    print("\n Result for  example $xFileName for ipotetic path ")
                    print("\n   inode[$potin] ---> onode[$potout]  is  return code=$rc")
                    print(", status = " + net.status)
                }


                // after reset all value of net
                net.flush()


                // ok : the propagation is completed
            } catch (e: Throwable) {
                System.err.println("$e : error during read $xFileName")
            }
            xFile.IOseqCloseR()
        } else System.err.print("\n : error during open $xFileName")
        println("\n\n End of experiment")
    }
}