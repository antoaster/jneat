/* Generated by Together */
package jneat

import jNeatCommon.NeatConstant
import jNeatCommon.NeatRoutine
import java.util.*

class Network(
        /**
         * Is a collection of object NNode can be mapped in a Vector container;
         * this collection represent a group of references to input nodes;
         */
        val inputs: List<NNode>,
        /**
         * Is a collection of object NNode can be mapped in a Vector container;
         * this collection represent a group of references to output nodes;
         */
        var outputs: List<NNode>,
        /**
         * Is a collection of object NNode can be mapped in a Vector container;
         * this collection represent a group of references to all nodes of this net;
         */
        var allnodes: List<NNode>, xnet_id: Int) {

    /**
     * is a reference to genotype can has  originate this fenotype
     */
    var genotype: Genome? = null

    /**
     * Is a name of this network
     */
    var name: String? = null

    /**
     * Numeric identification of this network
     */
    var net_id: Int

    /**
     * Number of NNodes of this net
     */
    var numnodes: Int

    /**
     * Number of Link  in this net
     */
    var numlinks: Int
    fun activate(): Boolean {
        var itr_node: Iterator<*>
        var itr_link: Iterator<*>
        val tmpsum = 0.0
        var add_amount = 0.0 //For adding to the activesum
        var onetime = false //Make sure we at least activate once
        var abortcount = 0 //Used in case the output is somehow
        val tmpdouble = 0.0
        while (outputsoff() || !onetime) {
            ++abortcount
            if (abortcount >= 30) {
                print("\n *ERROR* Inputs disconnected from output!")

// 05.06.2002 commented 			   
//			   genotype.op_view();
//			   System.exit(4);
                return false
            }

            // For each node, compute the sum of its incoming activation
            itr_node = allnodes.iterator()
            while (itr_node.hasNext()) {
                val _node = itr_node.next() as NNode
                if (_node.type != NeatConstant.SENSOR) {
                    _node.activesum = 0.0 // reset activation value
                    _node.active_flag = false // flag node disabled
                    itr_link = _node.incoming.iterator()
                    while (itr_link.hasNext()) {
                        val _link = itr_link.next() as Link
                        if (!_link.time_delay) {
                            add_amount = _link.weight * _link.in_node.get_active_out()
                            if (_link.in_node.active_flag || _link.in_node.type == NeatConstant.SENSOR) _node.active_flag = true
                            _node.activesum += add_amount
                        } else {
                            add_amount = _link.weight * _link.in_node.get_active_out_td()
                            _node.activesum += add_amount
                        }
                    } //End for over incoming links
                } //End if _node.type !=SENSOR
            } //End for over all nodes

            // Now activate all the non-sensor nodes off their incoming activation
            itr_node = allnodes.iterator()
            while (itr_node.hasNext()) {
                val _node = itr_node.next() as NNode
                if (_node.type != NeatConstant.SENSOR) {
                    //Only activate if some active input came in
                    if (_node.active_flag) {
                        _node.last_activation2 = _node.last_activation
                        _node.last_activation = _node.activation
                        if (_node.ftype == NeatConstant.SIGMOID) _node.activation = NeatRoutine.fsigmoid(_node.activesum, 4.924273, 2.4621365)
                        _node.activation_count += 1.0
                    }
                }
            }
            onetime = true
        }
        return true
    }

    fun flush() {
        val itr_node: Iterator<*>

/*
// old version
		 itr_node = outputs.iterator();
		 while (itr_node.hasNext()) 
		 {
			NNode _node = ((NNode) itr_node.next());
			_node.flushback();
		 }
*/
// new version : the number of connection >> num of node defined
// thus is good to reset all nodes without respect connection
        itr_node = allnodes.iterator()
        while (itr_node.hasNext()) {
            val _node = itr_node.next() as NNode
            _node.resetNNode()
        }
    }

    fun load_sensors(sensvals: DoubleArray) {
        var counter = 0
        val itr_node: Iterator<*>
        itr_node = inputs.iterator()
        while (itr_node.hasNext()) {
            val _node = itr_node.next() as NNode
            if (_node.type == NeatConstant.SENSOR) _node.sensor_load(sensvals[counter++])
        }
    }

    /**
     * Find the maximum number of neurons between
     * an ouput and an input
     */
    fun max_depth(): Int {
        var _node: NNode
        val itr_node: Iterator<*>
        var cur_depth = 0
        var max = 0
        for (j in allnodes.indices) {
            _node = allnodes.elementAt(j) as NNode
            _node.inner_level = 0
            _node.is_traversed = false
        }
        itr_node = outputs.iterator()
        while (itr_node.hasNext()) {
            _node = itr_node.next() as NNode
            cur_depth = _node.depth(0, this, max)
            if (cur_depth > max) max = cur_depth
        }
        return max
    }

    fun outputsoff(): Boolean {
        var itr_node: Iterator<*> = outputs.iterator()
        itr_node = outputs.iterator()
        while (itr_node.hasNext()) {
            val _node = itr_node.next() as NNode
            if (_node.activation_count == 0.0) return true
        }
        return false
    }

    fun viewAllNodes(s: String?) {
        println(s)
        print("\n\t - List of all nodes -")
        val itr_node: Iterator<*>
        itr_node = allnodes.iterator()
        while (itr_node.hasNext()) {
            val _node = itr_node.next() as NNode
            if (_node.active_flag) _node.op_view()
        }
        print("\n\t - end list of all nodes -")
    }

    /**
     * are user for working scope ; at this moment
     * is utilized for returning code of a search if recurrency
     * if ==  8 , the net has a loop ;
     */
    var status: Int
    fun count_motor(): Int {
        var counter = 0
        val itr_node: Iterator<*>

        // count # motor
        itr_node = outputs.iterator()
        while (itr_node.hasNext()) {
            val _node = itr_node.next() as NNode
            counter++
        }
        return counter
    }

    fun count_sensor(): Int {
        var counter = 0
        val itr_node: Iterator<*>
        itr_node = inputs.iterator()
        while (itr_node.hasNext()) {
            val _node = itr_node.next() as NNode
            if (_node.type == NeatConstant.SENSOR) counter++
        }
        return counter
    }

    fun has_a_path(potin: NNode, potout: NNode, level: Int, threshold: Int): Boolean {
        var _node: NNode? = null

        // reset all link to state no traversed
        for (j in allnodes.indices) {
            _node = allnodes.elementAt(j) as NNode
            _node.is_traversed = false
        }

        // call the control if has a link intra node potin , potout
        return is_recur(potin, potout, level, threshold)
    }

    /**
     * This module control if has at leat one
     * link from out and all sensor
     * It flow in all link and if at end are one sensor not
     * 'marked' , return false
     */
    fun is_minimal(): Boolean {
        var rc = false
        var ret_code = true
        var _node: NNode? = null
        var itr_node: Iterator<*>

        // reset all pending situation
        itr_node = allnodes.iterator()
        while (itr_node.hasNext()) {
            _node = itr_node.next() as NNode?
            _node!!.is_traversed = false
        }


        // attempted to excite all sensor
        itr_node = outputs.iterator()
        while (itr_node.hasNext()) {
            _node = itr_node.next() as NNode?
            rc = _node!!.mark(0, this)
            // the false conditions is for a net with loop
            // or an output without connection direct or indirect
            //
            if (rc == false) return false
        }

        // okay the virtual signal is flowed,
        // now control if all sensor of fenotype are touched :
        itr_node = inputs.iterator()
        while (itr_node.hasNext()) {
            _node = itr_node.next() as NNode?
            if (!_node!!.is_traversed) ret_code = false
        }
        return ret_code
    }

    /**
     *
     */
    fun is_recur(potin_node: NNode, potout_node: NNode, level: Int, thresh: Int): Boolean {
        var level = level
        var itr_link: Iterator<*>? = null
        level++
        if (level > thresh) {
            status = 8
            return false
        }
        return if (potin_node === potout_node) true else {
            itr_link = potin_node.incoming.iterator()
            while (itr_link.hasNext()) {
                val _link = itr_link.next() as Link
                if (!_link.is_recurrent) {
                    if (!_link.in_node.is_traversed) {
                        _link.in_node.is_traversed = true
                        if (is_recur(_link.in_node, potout_node, level, thresh)) return true
                    }
                }
            }
            potin_node.is_traversed = true
            false
        }
    }

    /**
     * starting from sensor , send a signal forward the net
     * after all nodes are active , control if last
     * activation is == current activation in output node
     * if activation of output nodes remain stable for 'period'
     * interval , return the difference from total cycle and
     * time passed from fist level stable.
     */
    fun is_stabilized(period: Int): Int {
        var period = period
        var itr_node: Iterator<*>
        var itr_link: Iterator<*>
        val tmpsum = 0.0
        var add_amount = 0.0 //For adding to the activesum
        var onetime = false //Make sure we at least activate once
        val abortcount = 0 //Used in case the output is somehow
        val tmpdouble = 0.0
        var _node: NNode? = null
        if (period == 0) period = 30


        //first step : activation of sensor nodes
        //
        itr_node = inputs.iterator()
        while (itr_node.hasNext()) {
            _node = itr_node.next() as NNode?
            if (_node!!.type == NeatConstant.SENSOR) {
                _node.last_activation2 = _node.last_activation
                _node.last_activation = _node.activation
                _node.activation_count++
                _node.activation = 1.0
            }
        }


        // activation of net
        //
        var done = false
        var time_passed = 0
        var counter_stable = 0
        var level = 0
        val limit = period + 90
        while (!done) {
            // if loop exit with signal of error
            if (time_passed >= limit) {
                //		 	System.out.print("\n *ALERT* this net is not STABLE after "+limit);
                return 0
            }

            // For each node, compute the sum of its incoming activation
            itr_node = allnodes.iterator()
            while (itr_node.hasNext()) {
                _node = itr_node.next() as NNode?
                if (_node!!.type != NeatConstant.SENSOR) {
                    _node.activesum = 0.0
                    _node.active_flag = false // flag node disabled
                    itr_link = _node.incoming.iterator()
                    while (itr_link.hasNext()) {
                        val _link = itr_link.next() as Link
                        if (!_link.time_delay) {
                            add_amount = _link.in_node.get_active_out()
                            if (_link.in_node.active_flag || _link.in_node.type == NeatConstant.SENSOR) {
                                _node.active_flag = true
                            }
                            _node.activesum += add_amount
                        } else {
                            add_amount = _link.in_node.get_active_out_td()
                            _node.activesum += add_amount
                        }
                    } //End for over incoming links
                } //End if _node.type !=SENSOR
            } //End for over all nodes

            // Now activate all the non-sensor nodes off their incoming activation
            itr_node = allnodes.iterator()
            while (itr_node.hasNext()) {
                _node = itr_node.next() as NNode?
                if (_node!!.type != NeatConstant.SENSOR) {
                    //Only activate if some active input came in
                    if (_node.active_flag) {
                        _node.last_activation2 = _node.last_activation
                        _node.last_activation = _node.activation
                        _node.activation = _node.activesum
                        _node.activation_count += 1.0
                    }
                }
            }
            onetime = true
            if (!outputsoff()) {
                //
                // verify is has a changement in any output(j-esimo)
                //
                var has_changed = false
                itr_node = outputs.iterator()
                while (itr_node.hasNext()) {
                    _node = itr_node.next() as NNode?
                    if (_node!!.last_activation != _node.activation) {
                        has_changed = true
                        break
                    }
                }
                if (!has_changed) {
                    // if has not changement, increment the counter
                    // of no change....
                    counter_stable += 1
                    // if counter no change  >= 'period' parameter (virtual depth) , the net is relaxed
                    // and stable , thus can be return the 'delta' passed
                    if (counter_stable >= period) {
                        done = true
                        level = time_passed
                        break
                    }
                } else counter_stable = 0
            }
            time_passed++
        }

        // return delta = total time passed (real) - period (depth virtual)
        return level - period + 1
    }

    /**
     * Insert the method's description here.
     * Creation date: (15/01/2002 8.08.13)
     */
    init {
        numnodes = -1
        numlinks = -1
        net_id = xnet_id
        status = 0
    }
}