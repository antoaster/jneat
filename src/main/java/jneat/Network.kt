/* Generated by Together */
package jneat

import jNeatCommon.NeatConstant
import jNeatCommon.NeatRoutine

class Network(
        /**
         * Is a collection of object NNode can be mapped in a Vector container;
         * this collection represent a group of references to input nodes;
         */
        val inputs: List<NNode>,
        /**
         * Is a collection of object NNode can be mapped in a Vector container;
         * this collection represent a group of references to output nodes;
         */
        var outputs: List<NNode>,
        /**
         * Is a collection of object NNode can be mapped in a Vector container;
         * this collection represent a group of references to all nodes of this net;
         */
        var allnodes: List<NNode>, xnet_id: Int) {

    var genotype: Genome? = null

    var name: String? = null

    var net_id: Int

    var numnodes: Int

    var numlinks: Int

    var status: Int

    fun activate(): Boolean {
        var abortcount = 0

        // push values through the network until all of the output nodes have been updated
        do {
            if (++abortcount > 30) {
                print("\n *ERROR* Inputs disconnected from output!")
                return false
            }
            stepNetwork()
        } while (outputsoff())
        return true
    }

    private fun stepNetwork() {
        // For each node, compute the sum of its incoming activation
        allnodes.forEach { _node ->
            _node.incoming.forEach { _link ->
                val add_amount = _link.weight * _link.in_node.get_active_out()
                if (_link.in_node.active_flag || _link.in_node.type == NeatConstant.SENSOR) _node.active_flag = true
                _node.activesum += add_amount
            }
        }

        // Now activate all the non-sensor nodes off their incoming activation

        allnodes.filter { it.type != NeatConstant.SENSOR }
                .filter { it.active_flag }
                .forEach { _node ->
                    _node.last_activation2 = _node.last_activation
                    _node.last_activation = _node.activation

                    // TODO: use a pluggable activation function here.
                    if (_node.ftype == NeatConstant.SIGMOID) _node.activation = NeatRoutine.fsigmoid(_node.activesum, 4.924273)
                    _node.activation_count += 1.0
                }
    }

    fun flush() {
        allnodes.forEach { it.resetNNode() }
    }

    fun load_sensors(sensvals: DoubleArray) {
        inputs.forEachIndexed {index, nNode ->
            nNode.sensor_load(sensvals[index])
        }
    }

    /**
     * Find the maximum number of neurons between
     * an ouput and an input
     */
    fun max_depth(): Int {
        var _node: NNode
        val itr_node: Iterator<*>
        var cur_depth = 0
        var max = 0
        for (j in allnodes.indices) {
            _node = allnodes.elementAt(j) as NNode
            _node.inner_level = 0
            _node.is_traversed = false
        }
        itr_node = outputs.iterator()
        while (itr_node.hasNext()) {
            _node = itr_node.next() as NNode
            cur_depth = _node.depth(0, this, max)
            if (cur_depth > max) max = cur_depth
        }
        return max
    }

    fun outputsoff() = outputs.any { it.activation_count == 0.0 }

    fun has_a_path(potin: NNode, potout: NNode, level: Int, threshold: Int): Boolean {

                // mama mia, why does this affect state?

        // reset all link to state no traversed
        allnodes.forEach { it.is_traversed = false }

        // call the control if has a link intra node potin , potout
        return is_recur(potin, potout, level, threshold)
    }

    /**
     * This module control if has at leat one
     * link from out and all sensor
     * It flow in all link and if at end are one sensor not
     * 'marked' , return false
     */
    fun is_minimal(): Boolean {
        var rc = false
        var ret_code = true
        var _node: NNode? = null
        var itr_node: Iterator<*>

        // reset all pending situation
        itr_node = allnodes.iterator()
        while (itr_node.hasNext()) {
            _node = itr_node.next() as NNode?
            _node!!.is_traversed = false
        }


        // attempted to excite all sensor
        itr_node = outputs.iterator()
        while (itr_node.hasNext()) {
            _node = itr_node.next() as NNode?
            rc = _node!!.mark(0, this)
            // the false conditions is for a net with loop
            // or an output without connection direct or indirect
            //
            if (rc == false) return false
        }

        // okay the virtual signal is flowed,
        // now control if all sensor of fenotype are touched :
        itr_node = inputs.iterator()
        while (itr_node.hasNext()) {
            _node = itr_node.next() as NNode?
            if (!_node!!.is_traversed) ret_code = false
        }
        return ret_code
    }

    /**
     *
     */
    fun is_recur(potin_node: NNode, potout_node: NNode, level: Int, thresh: Int): Boolean {
        var level = level
        var itr_link: Iterator<*>? = null
        level++
        if (level > thresh) {
            status = 8
            return false
        }
        return if (potin_node === potout_node) true else {
            itr_link = potin_node.incoming.iterator()
            while (itr_link.hasNext()) {
                val _link = itr_link.next() as Link
                if (!_link.is_recurrent) {
                    if (!_link.in_node.is_traversed) {
                        _link.in_node.is_traversed = true
                        if (is_recur(_link.in_node, potout_node, level, thresh)) return true
                    }
                }
            }
            potin_node.is_traversed = true
            false
        }
    }

    /**
     * starting from sensor , send a signal forward the net
     * after all nodes are active , control if last
     * activation is == current activation in output node
     * if activation of output nodes remain stable for 'period'
     * interval , return the difference from total cycle and
     * time passed from fist level stable.
     *
     * mama mia, this seems to have a copy of a bunch of the code I've already been trying to remove.
     */
    fun is_stabilized(period: Int): Int {
        var period = period
        var itr_node: Iterator<*>
        var itr_link: Iterator<*>
        val tmpsum = 0.0
        var add_amount = 0.0 //For adding to the activesum
        var onetime = false //Make sure we at least activate once
        val abortcount = 0 //Used in case the output is somehow
        val tmpdouble = 0.0
        var _node: NNode? = null
        if (period == 0) period = 30


        //first step : activation of sensor nodes
        //
        itr_node = inputs.iterator()
        while (itr_node.hasNext()) {
            _node = itr_node.next() as NNode?
            if (_node!!.type == NeatConstant.SENSOR) {
                _node.last_activation2 = _node.last_activation
                _node.last_activation = _node.activation
                _node.activation_count++
                _node.activation = 1.0
            }
        }


        // activation of net
        //
        var done = false
        var time_passed = 0
        var counter_stable = 0
        var level = 0
        val limit = period + 90
        while (!done) {
            // if loop exit with signal of error
            if (time_passed >= limit) {
                //		 	System.out.print("\n *ALERT* this net is not STABLE after "+limit);
                return 0
            }

            // For each node, compute the sum of its incoming activation
            itr_node = allnodes.iterator()
            while (itr_node.hasNext()) {
                _node = itr_node.next() as NNode?
                if (_node!!.type != NeatConstant.SENSOR) {
                    _node.activesum = 0.0
                    _node.active_flag = false // flag node disabled
                    itr_link = _node.incoming.iterator()
                    while (itr_link.hasNext()) {
                        val _link = itr_link.next() as Link
                        add_amount = _link.in_node.get_active_out()
                        if (_link.in_node.active_flag || _link.in_node.type == NeatConstant.SENSOR) {
                            _node.active_flag = true
                        }
                        _node.activesum += add_amount
                    } //End for over incoming links
                } //End if _node.type !=SENSOR
            } //End for over all nodes

            // Now activate all the non-sensor nodes off their incoming activation
            itr_node = allnodes.iterator()
            while (itr_node.hasNext()) {
                _node = itr_node.next() as NNode?
                if (_node!!.type != NeatConstant.SENSOR) {
                    //Only activate if some active input came in
                    if (_node.active_flag) {
                        _node.last_activation2 = _node.last_activation
                        _node.last_activation = _node.activation
                        _node.activation = _node.activesum
                        _node.activation_count += 1.0
                    }
                }
            }
            onetime = true
            if (!outputsoff()) {
                //
                // verify is has a changement in any output(j-esimo)
                //
                var has_changed = false
                itr_node = outputs.iterator()
                while (itr_node.hasNext()) {
                    _node = itr_node.next() as NNode?
                    if (_node!!.last_activation != _node.activation) {
                        has_changed = true
                        break
                    }
                }
                if (!has_changed) {
                    // if has not changement, increment the counter
                    // of no change....
                    counter_stable += 1
                    // if counter no change  >= 'period' parameter (virtual depth) , the net is relaxed
                    // and stable , thus can be return the 'delta' passed
                    if (counter_stable >= period) {
                        done = true
                        level = time_passed
                        break
                    }
                } else counter_stable = 0
            }
            time_passed++
        }

        // return delta = total time passed (real) - period (depth virtual)
        return level - period + 1
    }

    /**
     * Insert the method's description here.
     * Creation date: (15/01/2002 8.08.13)
     */
    init {
        numnodes = -1
        numlinks = -1
        net_id = xnet_id
        status = 0
    }
}