/* Generated by Together */
package jneat

import jNeatCommon.IOseq
import jNeatCommon.NeatConstant
import jNeatCommon.NeatRoutine
import java.text.DecimalFormat
import java.util.*

class Species : Neat {
    /**
     * id(-entification) of this species
     */
    @JvmField
    var id: Int

    /**
     * The age of the Species
     */
    @JvmField
    var age: Int

    /**
     * The average fitness of the Species
     */
    var ave_fitness: Double

    /**
     * Max fitness of the Species
     */
    var max_fitness: Double

    /**
     * The max it ever had
     */
    var max_fitness_ever: Double

    /**
     * how many child expected
     */
    @JvmField
    var expected_offspring: Int

    /**
     * is new species ?
     */
    @JvmField
    var novel: Boolean

    /**
     * has tested ?
     */
    var checked = false

    /**
     * list of all organisms in the Species
     */
    @JvmField
    var organisms: MutableList<Organism> = ArrayList()

    /**
     * how many time from last updt?
     * If this is too long ago, the Species will goes extinct.
     */
    @JvmField
    var age_of_last_improvement: Int
    fun getOrganisms(): List<Organism> {
        return organisms
    }

    /**
     * costructor with inly  ID of specie
     */
    constructor(i: Int) {
        id = i
        age = 1
        ave_fitness = 0.0
        expected_offspring = 0
        novel = false
        age_of_last_improvement = 0
        max_fitness = 0.0
        max_fitness_ever = 0.0
    }

    /**
     * add an organism to list of organisms in this specie
     */
    fun add_Organism(xorganism: Organism) {
        organisms.add(xorganism)
    }

    /**
     * Can change the fitness of the organisms
     * in the Species to be higher for very new species
     * (to protect them);
     * Divides the fitness by the size of the Species,
     * so that fitness is "shared" by the species
     * At end mark the organisms can be eliminated from this specie
     */
    fun adjust_fitness() {
        val itr_organism: Iterator<Organism>
        var _organism: Organism? = null
        var num_parents = 0
        var count = 0
        var age_debt = 0
        var j: Int
        age_debt = age - age_of_last_improvement + 1 - p_dropoff_age
        if (age_debt == 0) age_debt = 1
        val size1 = organisms.size
        j = 0
        while (j < size1) {
            _organism = organisms[j]

            //Remember the original fitness before it gets modified
            _organism.orig_fitness = _organism.fitness

            //Make fitness decrease after a stagnation point dropoff_age
            //Added an if to keep species pristine until the dropoff point
            if (age_debt >= 1) {
                _organism.fitness = _organism.fitness * 0.01
                //		 	System.out.print("\n dropped fitness to " + _organism.fitness);
            }
            //Give a fitness boost up to some young age (niching)
            //The age_significance parameter is a system parameter
            //  if it is 1, then young species get no fitness boost
            if (age <= 10) _organism.fitness = _organism.fitness * p_age_significance
            //Do not allow negative fitness
            if (_organism.fitness < 0.0) _organism.fitness = 0.0001
            //Share fitness with the species
            _organism.fitness = _organism.fitness / size1
            j++
        }

        //Sort the population and mark for death those after survival_thresh * pop_size


        organisms = organisms.sortedByDescending { it.fitness  }.toMutableList()

        //Update age_of_last_improvement here
        // (the first organism has the best fitness)
        if (organisms[0].orig_fitness > max_fitness_ever) {
            age_of_last_improvement = age
            max_fitness_ever = organisms[0].orig_fitness
        }

        //Decide how many get to reproduce based on survival_thresh*pop_size
        //Adding 1.0 ensures that at least one will survive
        // floor is the largest (closest to positive infinity) double value that is not greater
        // than the argument and is equal to a mathematical integer
        num_parents = Math.floor(p_survival_thresh * size1.toDouble() + 1.0).toInt()

        //Mark for death those who are ranked too low to be parents
        //Mark the champ as such
        organisms[0].champion = true
        itr_organism = organisms.iterator()
        count = 1

        // TODO: is this just a dumb way of counting?
        while (itr_organism.hasNext() && count <= num_parents) {
            _organism = itr_organism.next()
            count++
        }

        //found organism can be eliminated !
        while (itr_organism.hasNext()) {
            _organism = itr_organism.next()
            //Mark for elimination
            _organism.eliminate = true
        }
    }

    /**
     * Read all organisms in this species and compute
     * the summary of fitness;
     * at and  compute the average fitness (ave_fitness)
     * with :    ave_fitness = summary / (number of organisms)
     * this is an average fitness for this specie
     */
    fun compute_average_fitness() {
        val itr_organism: Iterator<*>
        itr_organism = organisms.iterator()
        var total = 0.0
        val size1 = organisms.size
        while (itr_organism.hasNext()) {
            total += itr_organism.next().fitness
        }
        ave_fitness = total / size1.toDouble()
    }

    /**
     * Read all organisms in this specie and return
     * the maximum fitness of all organisms.
     */
    fun compute_max_fitness() {
        var max = 0.0
        val total = 0.0
        val itr_organism: Iterator<*>
        itr_organism = organisms.iterator()
        while (itr_organism.hasNext()) {
            val _organism = itr_organism.next()
            if (_organism.fitness > max) max = _organism.fitness
        }
        max_fitness = max
    }

    /**
     * Compute the collective offspring the entire
     * species (the sum of all organism's offspring)
     * is assigned
     * skim is fractional offspring left over from a
     * previous species that was counted.
     * These fractional parts are kept unil they add
     * up to 1
     */
    fun count_offspring(skim: Double): Double {
        val itr_organism: Iterator<*>
        expected_offspring = 0
        var x1 = 0.0
        val y1 = 1.0
        var r1 = 0.0
        var r2 = skim
        var n1 = 0
        var n2 = 0
        itr_organism = organisms.iterator()
        while (itr_organism.hasNext()) {
            x1 = itr_organism.next().expected_offspring
            n1 = (x1 / y1).toInt()
            r1 = x1 - (x1 / y1).toInt() * y1
            n2 = n2 + n1
            r2 = r2 + r1
            if (r2 >= 1.0) {
                n2 = n2 + 1
                r2 = r2 - 1.0
            }
        }
        expected_offspring = n2
        return r2
    }

    /**
     * Called for printing in a file statistics information
     * for this specie.
     */
    fun print_to_filename(xNameFile: String?) {
        //
        // write to file genome in native format (for re-read)
        //
        val xFile: IOseq
        xFile = IOseq(xNameFile)
        xFile.IOseqOpenW(false)
        try {
            print_to_file(xFile)
        } catch (e: Throwable) {
            System.err.println(e)
        }
        xFile.IOseqCloseW()
    }

    fun viewtext() {
        println("\n +SPECIES : ")
        print("  id < $id >")
        print(" age=$age")
        print(", ave_fitness=$ave_fitness")
        print(", max_fitness=$max_fitness")
        print(", max_fitness_ever =$max_fitness_ever")
        print(", expected_offspring=$expected_offspring")
        print(", age_of_last_improvement=$age_of_last_improvement")
        print("""
  This Species has ${organisms.size} organisms :""")
        print("\n ---------------------------------------")
        var itr_organism: Iterator<*> = organisms.iterator()
        itr_organism = organisms.iterator()
        while (itr_organism.hasNext()) {
            itr_organism.next().viewtext()
        }
    }

    /**
     * costructor with identification and flag for signaling if its a new specie
     */
    constructor(i: Int, n: Boolean) {
        id = i
        age = 1
        ave_fitness = 0.0
        expected_offspring = 0
        novel = n
        age_of_last_improvement = 0
        max_fitness = 0.0
        max_fitness_ever = 0.0
    }

    /**
     * Compute generations since last improvement
     */
    fun last_improved(): Int {
        return age - age_of_last_improvement
    }

    /**
     * Eliminate the organism passed in parameter list,
     * from a list of organisms of this specie
     */
    fun remove_org(org: Organism) {
        val rc = organisms.remove(org)
        if (!rc) print("\n ALERT: Attempt to remove nonexistent Organism from Species")
    }

    /**
     *
     */
    fun reproduce(generation: Int, pop: Population, sorted_species: List<Species>): Boolean {
        var champ_done = false //Flag the preservation of the champion

        //outside the species
        var mut_struct_baby: Boolean
        var mate_baby: Boolean
        var giveup = 0 //For giving up finding a mate
        var count = 0
        var poolsize = 0
        var orgnum = 0
        var randspeciesnum = 0

        //The weight mutation power is species specific depending on its age
        val mut_power = p_weight_mut_power
        var randmult = 0.0
        var itr_specie: Iterator<*>
        var newspecies: Species? = null
        var compare_org: Organism? = null
        var thechamp: Organism? = null
        var mom: Organism? = null
        var baby: Organism? = null
        var new_genome: Genome? = null
        var _organism: Organism? = null
        var _dad: Organism? = null
        var randspecies: Species? = null
        if (expected_offspring > 0 && organisms.size == 0) {
            print("\n ERROR:  ATTEMPT TO REPRODUCE OUT OF EMPTY SPECIES")
            return false
        }

        // elements for this specie
        poolsize = organisms.size - 1

        // the champion of the 'this' specie is the first element of the specie;
        thechamp = organisms[0]


        //Create the designated number of offspring for the Species
        //one at a time
        count = 0
        while (count < expected_offspring) {
            mut_struct_baby = false
            mate_baby = false
            if (expected_offspring > p_pop_size) {
                print("\n ALERT: EXPECTED OFFSPRING = $expected_offspring")
            }

            //
            //If we have a super_champ (Population champion), finish off some special clones
            //
            //  System.out.print("\n verifica select....");
            if (thechamp.super_champ_offspring > 0) {

                //		 	System.out.print("\n analysis of champion #"+count);
                // save in mom current champ;
                mom = thechamp
                // create a new genome from this copy
                new_genome = mom.genome.duplicate(count)
                if (thechamp.super_champ_offspring > 1) {
                    if (NeatRoutine.randfloat() < .8 || p_mutate_add_link_prob == 0.0) new_genome.mutate_link_weight(mut_power, 1.0, NeatConstant.GAUSSIAN) else {
                        //Sometimes we add a link to a superchamp
                        val net_analogue = new_genome.genesis(generation)
                        new_genome.mutate_add_link(pop, p_newlink_tries)
                        mut_struct_baby = true
                    }
                }
                baby = Organism(0.0, new_genome, generation)
                if (thechamp.super_champ_offspring == 1) {
                    if (thechamp.pop_champ) {
                        //			   		System.out.print("\n The new org baby's (champion) genome is : "+baby.genome.getGenome_id());
                        baby.pop_champ_child = true
                        baby.high_fit = mom.orig_fitness
                    }
                }
                thechamp.super_champ_offspring--
            } //end population champ
            else if (!champ_done && expected_offspring > 5) {
                mom = thechamp //Mom is the champ
                new_genome = mom.genome.duplicate(count)
                baby = Organism(0.0, new_genome, generation) //Baby is just like mommy
                champ_done = true
            } else if (NeatRoutine.randfloat() < p_mutate_only_prob || poolsize == 1) {
                //Choose the random parent
                orgnum = NeatRoutine.randint(0, poolsize)
                _organism = organisms[orgnum]
                mom = _organism
                new_genome = mom!!.genome.duplicate(count)

                //Do the mutation depending on probabilities of
                //various mutations
                if (NeatRoutine.randfloat() < p_mutate_add_node_prob) {
                    //	System.out.print("\n ....species.reproduce.mutate add node");
                    new_genome.mutate_add_node(pop)
                    mut_struct_baby = true
                } else if (NeatRoutine.randfloat() < p_mutate_add_link_prob) {
                    //System.out.print("\n ....mutate add link");
                    val net_analogue = new_genome.genesis(generation)
                    new_genome.mutate_add_link(pop, p_newlink_tries)
                    mut_struct_baby = true
                } else {

                    //If we didn't do a structural mutation, we do the other kinds
                    if (NeatRoutine.randfloat() < p_mutate_random_trait_prob) {
                        //System.out.print("\n    ...mutate random trait");
                        new_genome.mutate_random_trait()
                    }
                    if (NeatRoutine.randfloat() < p_mutate_link_trait_prob) {
                        //    System.out.print("\n    ...mutate linktrait");
                        new_genome.mutate_link_trait(1)
                    }
                    if (NeatRoutine.randfloat() < p_mutate_node_trait_prob) {
                        //System.out.print("\n    ...mutate node trait");
                        new_genome.mutate_node_trait(1)
                    }
                    if (NeatRoutine.randfloat() < p_mutate_link_weights_prob) {
                        //System.out.print("\n    ...mutate link weight");
                        new_genome.mutate_link_weight(mut_power, 1.0, NeatConstant.GAUSSIAN)
                    }
                    if (NeatRoutine.randfloat() < p_mutate_toggle_enable_prob) {
                        //System.out.print("\n    ...mutate toggle enable");
                        new_genome.mutate_toggle_enable(1)
                    }
                    if (NeatRoutine.randfloat() < p_mutate_gene_reenable_prob) {
                        //System.out.print("\n    ...mutate gene_reenable:");
                        new_genome.mutate_gene_reenable()
                    }
                } //
                baby = Organism(0.0, new_genome, generation)
            } else {
                //Choose the random mom
                //System.out.print("\n mating .............");
                orgnum = NeatRoutine.randint(0, poolsize)
                _organism = organisms[orgnum]
                // save in mom
                mom = _organism
                //Choose random dad
                //Mate within Species
                if (NeatRoutine.randfloat() > p_interspecies_mate_rate) {
                    orgnum = NeatRoutine.randint(0, poolsize)
                    _organism = organisms[orgnum]
                    _dad = _organism
                } else {
                    //save current species
                    randspecies = this
                    //Select a random species
                    giveup = 0
                    var sp_ext = 0
                    //Give up if you cant find a different Species
                    while (randspecies === this && giveup < 5) {
                        //This old way just chose any old species
                        //randspeciesnum=NeatRoutine.randint(0,pop.species.size()-1);
                        //Choose a random species tending towards better species
                        randmult = NeatRoutine.gaussrand() / 4
                        if (randmult > 1.0) randmult = 1.0
                        //This tends to select better species
                        randspeciesnum = Math.floor(randmult * (sorted_species.size - 1.0) + 0.5).toInt()
                        sp_ext = 0
                        while (sp_ext < randspeciesnum) {
                            sp_ext++
                        }
                        randspecies = sorted_species[sp_ext]
                        ++giveup
                    }
                    _dad = randspecies!!.organisms[0]
                }
                new_genome = if (NeatRoutine.randfloat() < p_mate_multipoint_prob) {
                    // System.out.print("\n    mate multipoint baby: ");
                    mom!!.genome.mate_multipoint(_dad!!.genome, count, mom.orig_fitness, _dad.orig_fitness)
                } else if (NeatRoutine.randfloat() < p_mate_multipoint_avg_prob / (p_mate_multipoint_avg_prob + p_mate_singlepoint_prob)) {
                    // System.out.print("\n    mate multipoint_avg baby: ");
                    mom!!.genome.mate_multipoint_avg(_dad!!.genome, count, mom.orig_fitness, _dad.orig_fitness)
                } else {
                    // System.out.print("\n    mate siglepoint baby: ");
                    mom!!.genome.mate_singlepoint(_dad!!.genome, count)
                }
                mate_baby = true

                //Determine whether to mutate the baby's Genome
                //This is done randomly or if the mom and dad are the same organism
                if (NeatRoutine.randfloat() > p_mate_only_prob || _dad.genome.genome_id == mom.genome.genome_id || _dad.genome.compatibility(mom.genome) == 0.0) {

                    //Do the mutation depending on probabilities of
                    //various mutations
                    if (NeatRoutine.randfloat() < p_mutate_add_node_prob) {
                        //System.out.print("\n ....species.mutate add node2");
                        new_genome.mutate_add_node(pop)
                        mut_struct_baby = true
                    } else if (NeatRoutine.randfloat() < p_mutate_add_link_prob) {
                        //       System.out.print("\n ....mutate add link2");
                        val net_analogue = new_genome.genesis(generation)
                        new_genome.mutate_add_link(pop, p_newlink_tries)
                        mut_struct_baby = true
                    } else {

                        //If we didn't do a structural mutation, we do the other kinds
                        if (NeatRoutine.randfloat() < p_mutate_random_trait_prob) {
                            //                 System.out.print("\n    ...mutate random trait");
                            new_genome.mutate_random_trait()
                        }
                        if (NeatRoutine.randfloat() < p_mutate_link_trait_prob) {
                            //                  System.out.print("\n    ...mutate linktrait");
                            new_genome.mutate_link_trait(1)
                        }
                        if (NeatRoutine.randfloat() < p_mutate_node_trait_prob) {
                            //                  System.out.print("\n    ...mutate node trait");
                            new_genome.mutate_node_trait(1)
                        }
                        if (NeatRoutine.randfloat() < p_mutate_link_weights_prob) {
                            //                 System.out.print("\n    ...mutate link weight");
                            new_genome.mutate_link_weight(mut_power, 1.0, NeatConstant.GAUSSIAN)
                        }
                        if (NeatRoutine.randfloat() < p_mutate_toggle_enable_prob) {
                            //                System.out.print("\n    ...mutate toggle enable");
                            new_genome.mutate_toggle_enable(1)
                        }
                        if (NeatRoutine.randfloat() < p_mutate_gene_reenable_prob) {
                            //                System.out.print("\n    ...mutate gene_reenable:");
                            new_genome.mutate_gene_reenable()
                        }
                    } //
                    baby = Organism(0.0, new_genome, generation)
                } // end block of prob
                else {
                    //Create the baby without mutating first
                    baby = Organism(0.0, new_genome, generation)
                }
            }

            //Add the baby to its proper Species
            //If it doesn't fit a Species, create a new one
            baby.mut_struct_baby = mut_struct_baby
            baby.mate_baby = mate_baby


            // if list species is empty , create the first species!
            if (pop.species.isEmpty()) {
                pop.last_species++
                newspecies = Species(pop.last_species, true) // create a new specie
                pop.species.add(newspecies) // add this species to list of species
                newspecies.add_Organism(baby) // add this baby to species
                baby.species = newspecies // Point baby to owner specie
            } else {
                // looop in all species.... (each species is a Vector of organism...) of  population 'pop'
                //System.out.print("\n    this is case of population with species pree-existent");
                itr_specie = pop.species.iterator()
                var done = false
                while (!done && itr_specie.hasNext()) {
                    // point _species-esima
                    val _specie = itr_specie.next() as Species
                    // point to first organism of this _specie-esima
                    compare_org = _specie.getOrganisms()[0]
                    // compare _organism-esimo('_organism') with first organism in current specie('compare_org')
                    val curr_compat = baby.genome.compatibility(compare_org.genome)

                    //System.out.print("\n     affinity = "+curr_compat);
                    if (curr_compat < p_compat_threshold) {
                        //Found compatible species, so add this baby to it
                        _specie.add_Organism(baby)
                        //update in baby pointer to its species
                        baby.species = _specie
                        //force exit from this block ...
                        done = true
                    }
                }
                if (!done) {
                    pop.last_species++
                    newspecies = Species(pop.last_species, true) // create a new specie
                    pop.species.add(newspecies) // add this species to list of species
                    newspecies.add_Organism(baby) // add this baby to species
                    baby.species = newspecies // Point baby to owner specie
                }
            } // end block control and update species
            count++
        }
        return true
    }

    /**
     * Print to file all statistics information for this specie;
     * are information for specie, organisms,winner if present and genome
     */
    fun print_to_file(xFile: IOseq) {
        val mask4 = " 000"
        val fmt4 = DecimalFormat(mask4)
        val mask13 = " 0.000"
        val fmt13 = DecimalFormat(mask13)

        //Print a comment on the Species info
        var s2 = StringBuffer("/* Species #")
        s2.append(fmt4.format(id.toLong()))
        s2.append("         : (size=")
        s2.append(fmt4.format(organisms.size.toLong()))
        s2.append(") (AvfFit=")
        s2.append(fmt13.format(ave_fitness))
        s2.append(") (Age=")
        s2.append(fmt13.format(age.toLong()))
        s2.append(")  */")
        xFile.IOseqWrite(s2.toString())


        //   	System.out.print("\n" + s2);
        s2 = StringBuffer("/*-------------------------------------------------------------------*/")
        xFile.IOseqWrite(s2.toString())
        val itr_organism: Iterator<Organism> = organisms.iterator()
        while (itr_organism.hasNext()) {
            val _organism = itr_organism.next()
            s2 = StringBuffer("/* Organism #")
            s2.append(fmt4.format(_organism.genome.genome_id.toLong()))
            s2.append(" Fitness: ")
            s2.append(fmt13.format(_organism.fitness))
            s2.append(" Error: ")
            s2.append(fmt13.format(_organism.error))
            s2.append("                      */")
            xFile.IOseqWrite(s2.toString())
            if (_organism.winner) {
                s2 = StringBuffer("/*  $  This organism is WINNER with genome_id ")
                s2.append(fmt4.format(_organism.genome.genome_id.toLong()))
                s2.append(" Species #")
                s2.append(fmt4.format(id.toLong()))
                s2.append(" $   */")
                xFile.IOseqWrite(s2.toString())
            }
            _organism.genome.print_to_file(xFile)
        }
        s2 = StringBuffer("/*-------------------------------------------------------------------*/")
        xFile.IOseqWrite(s2.toString())
    }
}