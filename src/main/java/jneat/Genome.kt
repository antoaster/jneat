/* Generated by Together */
package jneat

import jNeatCommon.IOseq
import jNeatCommon.NeatConstant
import jNeatCommon.NeatRoutine
import java.text.DecimalFormat
import java.util.*

class Genome {
    /**
     * Is a reference from this genotype to fenotype
     */
    var phenotype: Network? = null

    /**
     * Numeric identification for this genotype
     */
    var genome_id: Int

    /**
     * Each Gene in (3) has a marker telling when it arose historically;
     * Thus, these Genes can be used to speciate the population, and
     * the list of Genes provide an evolutionary history of innovation and link-building
     */
    val genes : MutableList<Gene>;

    /**
     * parameter conglomerations :Reserved parameter space for future use
     */
    val traits : MutableList<Trait>;

    /**
     * Is a collection of NNode mapped in a Vector;
     */
    val nodes : MutableList<NNode>;

    /**
     * note are two String for store statistics information
     * when genomes are readed (if exist : null otherwise);
     */
    @JvmField
    var notes: String? = null
    fun duplicate(new_id: Int): Genome {
        var newtrait: Trait? = null
        var traitptr: Trait? = null
        var assoc_trait: Trait? = null
        var newnode: NNode? = null
        var inode: NNode? = null
        var onode: NNode? = null
        var newgene: Gene? = null
        var newgenome: Genome? = null
        val traits_dup = mutableListOf<Trait>()
        val nodes_dup = mutableListOf<NNode>()
        val genes_dup = mutableListOf<Gene>()
        var _trait_id: Int
        var itr_trait: Iterator<*> = traits.iterator()
        var itr_node: Iterator<*> = nodes.iterator()
        var itr_gene: Iterator<*> = genes.iterator()
        /**
         * duplicate trait
         */
        itr_trait = traits.iterator()
        while (itr_trait.hasNext()) {
            val _trait = itr_trait.next() as Trait
            newtrait = Trait(_trait)
            traits_dup.add(newtrait)
        }
        /**
         * duplicate NNodes
         */
        itr_node = nodes.iterator()
        while (itr_node.hasNext()) {
            val _node = itr_node.next() as NNode
            assoc_trait = null
            if (_node.nodetrait != null) {
                _trait_id = _node!!.nodetrait!!.trait_id
                itr_trait = traits_dup.iterator()
                while (itr_trait.hasNext()) {
                    val _trait = itr_trait.next() as Trait
                    if (_trait.trait_id == _trait_id) {
                        assoc_trait = _trait
                        break
                    }
                }
            }
            newnode = NNode(_node, assoc_trait)
            _node.dup = newnode
            nodes_dup.add(newnode)
        }
        /**
         * duplicate Genes
         */
        itr_gene = genes.iterator()
        while (itr_gene.hasNext()) {
            val _gene = itr_gene.next() as Gene

            // point to news nodes created  at precedent step
            inode = _gene.lnk!!.in_node.dup
            onode = _gene.lnk!!.out_node.dup
            traitptr = _gene.lnk!!.linktrait
            assoc_trait = null
            if (traitptr != null) {
                _trait_id = traitptr.trait_id
                itr_trait = traits_dup.iterator()
                while (itr_trait.hasNext()) {
                    val _trait = itr_trait.next() as Trait
                    if (_trait.trait_id == _trait_id) {
                        assoc_trait = _trait
                        break
                    }
                }
            }

            // creation of new gene with a pointer to new node
            newgene = Gene(_gene, assoc_trait, inode!!, onode!!)
            genes_dup.add(newgene)
        }

        // okay all nodes created, the new genome can be generate
        newgenome = Genome(new_id, traits_dup, nodes_dup, genes_dup)
        return newgenome
    }

    /**
     *
     */
    constructor(id: Int, t: MutableList<Trait>, n: MutableList<NNode>, g: MutableList<Gene>) {
        genome_id = id
        traits = t
        nodes = n
        genes = g
        notes = null
        phenotype = null
    }

    fun mutate_link_weight(power: Double, rate: Double, mutation_type: Int) {
        val _weight = 0.0
        var num: Double //counts gene placement
        val gene_total: Double
        val powermod: Double //Modified power by gene number

        //The power of mutation will rise farther into the genome
        //on the theory that the older genes are more fit since
        //they have stood the test of time
        var randnum: Double
        var randchoice: Double //Decide what kind of mutation to do on a gene
        val endpart: Double //Signifies the last part of the genome
        var gausspoint: Double
        var coldgausspoint: Double
        val severe: Boolean //Once in a while really shake things up

        // for 50% of Prob. // severe is true
        severe = if (NeatRoutine.randfloat() > 0.5) true else false
        num = 0.0
        gene_total = genes.size.toDouble()
        endpart = gene_total * 0.8
        powermod = 1.0
        var itr_gene: Iterator<*> = genes.iterator()
        itr_gene = genes.iterator()
        while (itr_gene.hasNext()) {
            val _gene = itr_gene.next() as Gene
            if (severe) {
                gausspoint = 0.3
                coldgausspoint = 0.1
            } else {
                if (gene_total >= 10.0 && num > endpart) {
                    gausspoint = 0.5
                    coldgausspoint = 0.3
                } else {
                    if (NeatRoutine.randfloat() > 0.5) {
                        gausspoint = 1.0 - rate
                        coldgausspoint = 1.0 - rate - 0.1
                    } else {
                        gausspoint = 1.0 - rate
                        coldgausspoint = 1.0 - rate
                    }
                }
            }

            // choise a number from ]-1,+1[
            randnum = NeatRoutine.randposneg() * NeatRoutine.randfloat() * power * powermod
            if (mutation_type == NeatConstant.GAUSSIAN) {
                randchoice = NeatRoutine.randfloat() // a number from ]0,1[
                if (randchoice > gausspoint) _gene.lnk!!.weight += randnum else if (randchoice > coldgausspoint) _gene.lnk!!.weight = randnum
            } else if (mutation_type == NeatConstant.COLDGAUSSIAN) _gene.lnk!!.weight = randnum

            // copy to mutation_num, the current weight
            _gene.mutation_num = _gene.lnk!!.weight
            num += 1.0
        }
    }

    fun genesis(id: Int): Network {
        var newnet: Network? = null
        var curtrait: Trait? = null
        // Vector nodes_dup = new Vector(1, 0);
        var newnode: NNode? = null
        val inlist = mutableListOf<NNode>()
        val outlist = mutableListOf<NNode>()
        val all_list = mutableListOf<NNode>()
        var curlink: Link? = null
        var newlink: Link? = null
        var inode: NNode? = null
        var onode: NNode? = null
        var _trait_id: Int
        var itr_node: Iterator<*> = nodes.iterator()
        var itr_gene: Iterator<*> = genes.iterator()
        itr_node = nodes.iterator()
        while (itr_node.hasNext()) {
            val _node = itr_node.next() as NNode

            //create a copy of gene node for fenotype
            newnode = NNode(_node.type, _node.node_id)

            //Derive link's parameters from its Trait pointer
            // of nodetrait
            curtrait = _node.nodetrait
            newnode.derive_trait(curtrait)
            newnode.inner_level = 0

            //****ADD 19/02/2002
            newnode.gen_node_label = _node.gen_node_label
            //****END ADD


            // new field
            newnode.is_traversed = false
            if (_node.gen_node_label == NeatConstant.INPUT) inlist.add(newnode)
            if (_node.gen_node_label == NeatConstant.BIAS) inlist.add(newnode)
            if (_node.gen_node_label == NeatConstant.OUTPUT) outlist.add(newnode)

            // add to genotype the pointer to phenotype node
            all_list.add(newnode)
            _node.analogue = newnode
        }
        if (genes.size == 0) {
            print(
                    "\n ALERT : are a network whitout GENES; the result can unpredictable")
        }
        if (outlist.size == 0) {
            print(
                    "\n ALERT : are a network whitout OUTPUTS; the result can unpredictable")
            op_view()
        }
        itr_gene = genes.iterator()
        while (itr_gene.hasNext()) {
            val _gene = itr_gene.next() as Gene

            //Only create the link if the gene is enabled
            if (_gene.enable == true) {
                curlink = _gene.lnk
                inode = curlink!!.in_node.analogue
                onode = curlink.out_node.analogue
                //NOTE: This line could be run through a recurrency check if desired
                // (no need to in the current implementation of NEAT)
                newlink = Link(curlink.weight, inode!!, onode!!, curlink.is_recurrent)
                onode.incoming.add(newlink)
                inode.outgoing.add(newlink)

                //Derive link's parameters from its Trait pointer
                // of linktrait
                curtrait = curlink.linktrait
                curlink.derive_trait(curtrait)
            }
        }


        //Create the new network
        newnet = Network(inlist, outlist, all_list, id)
        //Attach genotype and phenotype together:
        //  newnet point to owner genotype (this)
        newnet.genotype = this
        //  genotype point to owner phenotype (newnet)
        phenotype = newnet
        return newnet
    }

    /**
     * This function gives a measure of compatibility between
     * two Genomes by computing a linear combination of 3
     * characterizing variables of their compatibilty.
     * The 3 variables represent PERCENT DISJOINT GENES,
     * PERCENT EXCESS GENES, MUTATIONAL DIFFERENCE WITHIN
     * MATCHING GENES.  So the formula for compatibility
     * is:  disjoint_coeff*pdg+excess_coeff*peg+mutdiff_coeff*mdmg.
     * The 3 coefficients are global system parameters
     */
    fun compatibility(g: Genome): Double {

        //Innovation numbers
        var p1innov: Double
        var p2innov: Double

        //Intermediate value
        var mut_diff: Double

        //Set up the counters
        var num_disjoint = 0.0
        var num_excess = 0.0
        var mut_diff_total = 0.0
        var num_matching = 0.0 //Used to normalize mutation_num differences
        var _gene1: Gene? = null
        var _gene2: Gene? = null
        val max_genome_size: Double //Size of larger Genome

        //Get the length of the longest Genome for percentage computations
        val size1 = genes.size
        val size2 = g.genes.size
        max_genome_size = Math.max(size1, size2).toDouble()
        //Now move through the Genes of each potential parent
        //until both Genomes end
        var j = 0
        var j1 = 0
        var j2 = 0
        j = 0
        while (j < max_genome_size) {
            if (j1 >= size1) {
                num_excess += 1.0
                j2++
            } else if (j2 >= size2) {
                num_excess += 1.0
                j1++
            } else {
                _gene1 = genes.elementAt(j1) as Gene
                _gene2 = g.genes.elementAt(j2) as Gene

                //Extract current innovation numbers
                p1innov = _gene1!!.innovation_num
                p2innov = _gene2!!.innovation_num
                if (p1innov == p2innov) {
                    num_matching += 1.0
                    mut_diff = Math.abs(_gene1.mutation_num - _gene2.mutation_num)
                    mut_diff_total += mut_diff
                    j1++
                    j2++
                } else if (p1innov < p2innov) {
                    j1++
                    num_disjoint += 1.0
                } else if (p2innov < p1innov) {
                    j2++
                    num_disjoint += 1.0
                }
            }
            j++
        }

        // Return the compatibility number using compatibility formula
        // Note that mut_diff_total/num_matching gives the AVERAGE
        // difference between mutation_nums for any two matching Genes
        // in the Genome.
        // Look at disjointedness and excess in the absolute (ignoring size)
        return Neat.p_disjoint_coeff * (num_disjoint / 1.0) + Neat.p_excess_coeff * (num_excess / 1.0) + Neat.p_mutdiff_coeff * (mut_diff_total / num_matching)
    }

    fun get_last_gene_innovnum(): Double {
        return (genes.last() as Gene).innovation_num + 1
    }

    fun get_last_node_id(): Int {
        return (nodes.last() as NNode).node_id + 1
    }

    fun op_view() {
        print("\n GENOME START   id=$genome_id")
        print("""
  genes are :${genes.size}""")
        print("""
  nodes are :${nodes.size}""")
        print("""
  trait are :${traits.size}""")
        var itr_node: Iterator<*> = nodes.iterator()
        itr_node = nodes.iterator()
        while (itr_node.hasNext()) {
            val _node = itr_node.next() as NNode
            if (_node.gen_node_label == NeatConstant.INPUT) print("\n Input ")
            if (_node.gen_node_label == NeatConstant.OUTPUT) print("\n Output")
            if (_node.gen_node_label == NeatConstant.HIDDEN) print("\n Hidden")
            if (_node.gen_node_label == NeatConstant.BIAS) print("\n Bias  ")
            _node.op_view()
        }
        var itr_gene: Iterator<*> = genes.iterator()
        itr_gene = genes.iterator()
        while (itr_gene.hasNext()) {
            val _gene = itr_gene.next() as Gene
            _gene.op_view()
        }
        print("\n")
        print(" Traits:\n")
        var itr_trait: Iterator<*> = traits.iterator()
        itr_trait = traits.iterator()
        while (itr_trait.hasNext()) {
            val _trait = itr_trait.next() as Trait
            _trait.op_view()
        }
        print("\n")
        print(" GENOME END")
    }

    fun verify(): Boolean {
        var inode: NNode? = null
        var onode: NNode? = null
        var i1 = 0
        var o1 = 0
        var r1 = false
        var disab = false
        var last_id = 0
        var itr_gene: Iterator<*> = genes.iterator()
        var itr_gene1: Iterator<*> = genes.iterator()
        var itr_node: Iterator<*> = nodes.iterator()
        if (genes.size == 0) {
            //         System.out.print("\n DEBUG genome.costructor.genome.random");
            //         System.out.println("\n *ERROR* are not genes");
            return false
        }
        if (nodes.size == 0) {
            //         System.out.print("\n DEBUG genome.costructor.genome.random");
            //         System.out.println("\n *ERROR* are not nodes");
            return false
        }
        if (traits.size == 0) {
            //         System.out.print("\n DEBUG genome.costructor.genome.random");
            //         System.out.println(" *ERROR*\n are not traits");
            return false
        }

        // control if nodes in gene are defined and are the same nodes il nodes list
        itr_gene = genes.iterator()
        while (itr_gene.hasNext()) {
            val _gene = itr_gene.next() as Gene
            inode = _gene.lnk!!.in_node
            onode = _gene.lnk!!.out_node
            if (inode == null) {
                println(" *ERROR* inode = null in genome #$genome_id")
                return false
            }
            if (onode == null) {
                println(" *ERROR* onode = null in genome #$genome_id")
                return false
            }
            if (!nodes.contains(inode)) {
                println("Missing inode:  node defined in gene not found in Vector nodes of genome #"
                        + genome_id)
                print("""
 the inode is=${inode.node_id}""")
                return false
            }
            if (!nodes.contains(onode)) {
                println("Missing onode:  node defined in gene not found in Vector nodes of genome #"
                        + genome_id)
                print("""
 the onode is=${onode.node_id}""")
                return false
            }
        }

        // verify if list nodes is ordered
        itr_node = nodes.iterator()
        while (itr_node.hasNext()) {
            val _node = itr_node.next() as NNode
            if (_node.node_id < last_id) {
                println("ALERT: NODES OUT OF ORDER : ")
                println(
                        " last node_id is= " + last_id + " , current node_id=" + _node.node_id)
                return false
            }
            last_id = _node.node_id
        }

        // control in genes are gene duplicate for contents
        itr_gene = genes.iterator()
        while (itr_gene.hasNext()) {
            val _gene = itr_gene.next() as Gene
            i1 = _gene.lnk!!.in_node.node_id
            o1 = _gene.lnk!!.out_node.node_id
            r1 = _gene.lnk!!.is_recurrent
            itr_gene1 = itr_gene
            while (itr_gene1.hasNext()) {
                val _gene1 = itr_gene1.next() as Gene
                if (_gene1.lnk!!.in_node.node_id == i1 && _gene1.lnk!!.out_node.node_id == o1 && _gene1.lnk!!.is_recurrent == r1) {
                    print(" \n  ALERT: DUPLICATE GENES :")
                    print("  inp_node=$i1 out_node=$o1")
                    print("  in GENOME id -->$genome_id")
                    print("  gene1 is : ")
                    _gene.op_view()
                    print("  gene2 is : ")
                    _gene1.op_view()
                    return false
                }
            }
        }
        if (nodes.size >= 500) {
            disab = false
            itr_gene = genes.iterator()
            while (itr_gene.hasNext()) {
                val _gene = itr_gene.next() as Gene
                if (!_gene.enable && disab) {
                    print("""
 ALERT: 2 DISABLES IN A ROW: ${_gene.lnk!!.in_node.node_id}""")
                    print(" inp node=" + _gene.lnk!!.in_node.node_id)
                    print(" out node=" + _gene.lnk!!.out_node.node_id)
                    print(" for GENOME $genome_id")
                    print("\n Gene is :")
                    _gene.op_view()
                }
                disab = if (!_gene.enable) true else false
            }
        }
        return true
    }

    fun print_to_filename(xNameFile: String?) {
        //
        // write to file genome in native format (for re-read)
        //
        val xFile: IOseq
        xFile = IOseq(xNameFile)
        xFile.IOseqOpenW(false)
        try {
            print_to_file(xFile)
        } catch (e: Throwable) {
            System.err.println(e)
        }
        xFile.IOseqCloseW()
    }

    fun mate_multipoint(g: Genome, genomeid: Int, fitness1: Double, fitness2: Double): Genome {
        var new_genome: Genome? = null
        var disable = false //Set to true if we want to disabled a chosen gene
        val done = false
        val done_in = false
        val done_out = false

        //   int h = 0;
        var traitnum = 0
        var nodetraitnum = 0
        val len = 0
        var _curgene2: Gene? = null
        var newgene: Gene? = null
        var inode: NNode? = null
        var onode: NNode? = null
        var new_inode: NNode? = null
        var new_onode: NNode? = null
        var curnode: NNode? = null
        var chosengene: Gene? = null
        var _p1gene: Gene? = null
        var _p2gene: Gene? = null
        var newtrait: Trait? = null
        var _trait1: Trait? = null
        var _trait2: Trait? = null
        var p1innov = 0.0
        var p2innov = 0.0
        var j: Int
        var j1: Int
        var j2: Int


        //Tells if the first genome (this one) has better fitness or not
        var skip = false

        //First, average the Traits from the 2 parents to form the baby's Traits
        //It is assumed that trait vectors are the same length
        //In the future, may decide on a different method for
        //trait mating (corrispondenza)
        val len_traits = traits.size
        val newtraits = mutableListOf<Trait>()
        j = 0
        while (j < len_traits) {
            _trait1 = traits.elementAt(j) as Trait
            _trait2 = g.traits.elementAt(j) as Trait
            newtrait = Trait(_trait1, _trait2)
            newtraits.add(newtrait)
            j++
        }

        //Figure out which genome is better
        //The worse genome should not be allowed to add extra structural baggage
        //If they are the same, use the smaller one's disjoint and excess genes only
        var p1better = false
        val size1 = genes.size
        val size2 = g.genes.size
        if (fitness1 > fitness2) p1better = true else if (fitness1 == fitness2) {
            if (size1 < size2) p1better = true
        }
        val len_genome = Math.max(size1, size2)
        val len_nodes = nodes.size
        val newgenes = mutableListOf<Gene>()
        val newnodes = mutableListOf<NNode>()
        var itr_newgenes: Iterator<*>
        j1 = 0
        j2 = 0
        var control_disable = 0
        var exist_disable = 0
        while (j1 < size1 || j2 < size2) {
            //
            //  chosen of 'just' gene
            //
            skip = false //Default to not skipping a chosen gene
            if (j1 >= size1) {
                chosengene = g.genes.elementAt(j2) as Gene
                j2++
                if (p1better) skip = true //Skip excess from the worse genome
            } else if (j2 >= size2) {
                chosengene = genes.elementAt(j1) as Gene
                j1++
                if (!p1better) skip = true //Skip excess from the worse genome
            } else {
                _p1gene = genes.elementAt(j1) as Gene
                _p2gene = g.genes.elementAt(j2) as Gene
                p1innov = _p1gene!!.innovation_num
                p2innov = _p2gene!!.innovation_num
                if (p1innov == p2innov) {
                    chosengene = if (NeatRoutine.randfloat() < 0.5) _p1gene else _p2gene

                    //If one is disabled, the corresponding gene in the offspring
                    //will likely be disabled
                    disable = false
                    if (_p1gene.enable == false || _p2gene.enable == false) {
                        exist_disable++
                        if (NeatRoutine.randfloat() < 0.75) {
                            disable = true
                            control_disable++
                        }
                    }
                    j1++
                    j2++
                } else if (p1innov < p2innov) {
                    chosengene = _p1gene
                    j1++
                    if (!p1better) skip = true
                } else if (p2innov < p1innov) {
                    chosengene = _p2gene
                    j2++
                    if (p1better) skip = true
                }
            } // end chosen gene

            //
            //
            //Check to see if the chosengene conflicts with an already chosen gene
            //i.e. do they represent the same link
            //
            itr_newgenes = newgenes.iterator()
            while (itr_newgenes.hasNext()) {
                _curgene2 = itr_newgenes.next() as Gene?
                if (_curgene2!!.lnk!!.in_node.node_id == chosengene!!.lnk!!.in_node.node_id && _curgene2.lnk!!.out_node.node_id == chosengene.lnk!!.out_node.node_id && _curgene2.lnk!!.is_recurrent == chosengene.lnk!!.is_recurrent) {
                    skip = true
                    break
                }
                if (_curgene2.lnk!!.in_node.node_id == chosengene.lnk!!.out_node.node_id && _curgene2.lnk!!.out_node.node_id == chosengene.lnk!!.in_node.node_id && !_curgene2.lnk!!.is_recurrent
                        && !chosengene.lnk!!.is_recurrent) {
                    skip = true
                    break
                }
            }

            //
            //
            //
            if (!skip) {
                //Now add the chosengene to the baby
                //First, get the trait pointer
                val first_traitnum = (traits.first() as Trait).trait_id
                traitnum = if (chosengene!!.lnk!!.linktrait == null) first_traitnum else chosengene.lnk!!.linktrait!!.trait_id - first_traitnum

                //Next check for the nodes, add them if not in the baby Genome already
                inode = chosengene.lnk!!.in_node
                onode = chosengene.lnk!!.out_node

                //Check for inode in the newnodes list

                //
                //Check for inode, onode in the newnodes list
                //


                //--------------------------------------------------------------------------------
                var found: Boolean
                if (inode.node_id < onode.node_id) {
                    //
                    // search the inode
                    //
                    found = false
                    for (ix in newnodes.indices) {
                        curnode = newnodes.elementAt(ix) as NNode
                        if (curnode!!.node_id == inode.node_id) {
                            found = true
                            break
                        }
                    }

                    // if exist , point to exitsting version
                    if (found) new_inode = curnode else {
                        nodetraitnum = if (inode.nodetrait == null) 0 else inode!!.nodetrait!!.trait_id - first_traitnum
                        newtrait = newtraits.elementAt(nodetraitnum) as Trait
                        new_inode = NNode(inode, newtrait)
                        //insert in newnodes list
                        node_insert(newnodes, new_inode)
                    }


                    //
                    // search the onode
                    //
                    found = false
                    for (ix in newnodes.indices) {
                        curnode = newnodes.elementAt(ix) as NNode
                        if (curnode!!.node_id == onode.node_id) {
                            found = true
                            break
                        }
                    }

                    // if exist , point to exitsting version
                    if (found) new_onode = curnode else {
                        nodetraitnum = if (onode.nodetrait == null) 0 else onode!!.nodetrait!!.trait_id - first_traitnum
                        newtrait = newtraits.elementAt(nodetraitnum) as Trait
                        new_onode = NNode(onode, newtrait)
                        //insert in newnodes list
                        node_insert(newnodes, new_onode)
                    }
                } // end block : inode.node_id < onode.node_id
                else {


                    //
                    // search the onode
                    //
                    found = false
                    for (ix in newnodes.indices) {
                        curnode = newnodes.elementAt(ix) as NNode
                        if (curnode!!.node_id == onode.node_id) {
                            found = true
                            break
                        }
                    }

                    // if exist , point to exitsting version
                    if (found) new_onode = curnode else {
                        nodetraitnum = if (onode.nodetrait == null) 0 else onode!!.nodetrait!!.trait_id - first_traitnum
                        newtrait = newtraits.elementAt(nodetraitnum) as Trait
                        new_onode = NNode(onode, newtrait)
                        //insert in newnodes list
                        node_insert(newnodes, new_onode)
                    }


                    //
                    // search the inode
                    //
                    found = false
                    for (ix in newnodes.indices) {
                        curnode = newnodes.elementAt(ix) as NNode
                        if (curnode!!.node_id == inode.node_id) {
                            found = true
                            break
                        }
                    }

                    // if exist , point to exitsting version
                    if (found) new_inode = curnode else {
                        nodetraitnum = if (inode.nodetrait == null) 0 else inode.nodetrait!!.trait_id - first_traitnum
                        newtrait = newtraits.elementAt(nodetraitnum) as Trait
                        new_inode = NNode(inode, newtrait)
                        //insert in newnodes list
                        node_insert(newnodes, new_inode)
                    }
                }


                //--------------------------------------------------------------------------------


                //Add the Gene
                newtrait = newtraits.elementAt(traitnum) as Trait
                newgene = Gene(chosengene, newtrait, new_inode!!, new_onode!!)
                if (disable) {
                    newgene.enable = false
                    disable = false
                }
                newgenes.add(newgene!!)
            }
        } // end block genome (while)
        new_genome = Genome(genomeid, newtraits, newnodes!!, newgenes!!)


        // ----------------------------------------------------------------------------------------

        //	boolean h = new_genome.verify();
        var found = false
        for (ix in newnodes.indices) {
            curnode = newnodes.elementAt(ix) as NNode
            if (curnode!!.gen_node_label == NeatConstant.OUTPUT) {
                found = true
                break
            }
        }
        if (!found) {
            print("\n *--------------- not found output node ----------------------------")
            print("\n * during mate_multipoint : please control the following's *********")
            print("\n * control block : ")
            print("\n Genome A= ")
            op_view()
            print("\n Genome B= ")
            g.op_view()
            print("\n Result = ")
            new_genome.op_view()
            System.exit(0)
        }
        // ----------------------------------------------------------------------------------------
        return new_genome
    }

    fun mate_multipoint_avg(g: Genome, genomeid: Int, fitness1: Double, fitness2: Double): Genome {
        var new_genome: Genome? = null
        var disable = false //Set to true if we want to disabled a chosen gene
        val done = false
        val done_in = false
        val done_out = false
        var traitnum = 0
        var nodetraitnum = 0
        val len = 0
        var control_disable = 0
        var exist_disable = 0
        var chosengene: Gene? = null
        var _curgene2: Gene? = null
        var newgene: Gene? = null
        var inode: NNode? = null
        var onode: NNode? = null
        var new_inode: NNode? = null
        var new_onode: NNode? = null
        var curnode: NNode? = null
        var _p1gene: Gene? = null
        var _p2gene: Gene? = null
        var newtrait: Trait? = null
        var _trait1: Trait? = null
        var _trait2: Trait? = null
        var p1innov = 0.0
        var p2innov = 0.0
        var j: Int
        var j1: Int
        var j2: Int
        var skip = false


        //Set up the avgene
        val avgene = Gene(null as Trait?, 0.0, dummyNode(), dummyNode(), false, 0.0, 0.0)
        //First, average the Traits from the 2 parents to form the baby's Traits
        //It is assumed that trait vectors are the same length
        //In the future, may decide on a different method for
        //trait mating (corrispondenza)
        val len_traits = traits.size
        val newtraits = mutableListOf<Trait>()
        j = 0
        while (j < len_traits) {
            _trait1 = traits.elementAt(j) as Trait
            _trait2 = g.traits.elementAt(j) as Trait
            newtrait = Trait(_trait1, _trait2)
            newtraits.add(newtrait)
            j++
        }

        //Figure out which genome is better
        //The worse genome should not be allowed to add extra structural baggage
        //If they are the same, use the smaller one's disjoint and excess genes only
        var p1better = false
        val size1 = genes.size
        val size2 = g.genes.size
        if (fitness1 > fitness2) p1better = true else if (fitness1 == fitness2) {
            if (size1 < size2) p1better = true
        }
        val len_genome = Math.max(size1, size2)
        val len_nodes = nodes.size
        val newgenes = mutableListOf<Gene>()
        val newnodes = mutableListOf<NNode>()
        var itr_newgenes: Iterator<*>
        j1 = 0
        j2 = 0
        while (j1 < size1 || j2 < size2) //while (newgenes.size() < len_genome)
        {
            //
            //  chosen of 'just' gene
            //
            avgene.enable = true //Default to enabled
            skip = false //Default to not skipping a chosen gene
            if (j1 >= size1) {
                chosengene = g.genes.elementAt(j2) as Gene
                j2++
                if (p1better) skip = true //Skip excess from the worse genome
            } else if (j2 >= size2) {
                chosengene = genes.elementAt(j1) as Gene
                j1++
                if (!p1better) skip = true //Skip excess from the worse genome
            } else {
                _p1gene = genes.elementAt(j1) as Gene
                _p2gene = g.genes.elementAt(j2) as Gene
                p1innov = _p1gene!!.innovation_num
                p2innov = _p2gene!!.innovation_num
                if (p1innov == p2innov) {
                    if (NeatRoutine.randfloat() > 0.5) avgene.lnk!!.linktrait = _p1gene.lnk!!.linktrait else avgene.lnk!!.linktrait = _p2gene.lnk!!.linktrait

                    //WEIGHTS AVERAGED HERE
                    avgene.lnk!!.weight = (_p1gene.lnk!!.weight + _p2gene.lnk!!.weight) / 2.0
                    if (NeatRoutine.randfloat() > 0.5) avgene.lnk!!.in_node = _p1gene.lnk!!.in_node else avgene.lnk!!.in_node = _p2gene.lnk!!.in_node
                    if (NeatRoutine.randfloat() > 0.5) avgene.lnk!!.out_node = _p1gene.lnk!!.out_node else avgene.lnk!!.out_node = _p2gene.lnk!!.out_node
                    if (NeatRoutine.randfloat() > 0.5) avgene.lnk!!.is_recurrent = _p1gene.lnk!!.is_recurrent else avgene.lnk!!.is_recurrent = _p2gene.lnk!!.is_recurrent
                    avgene.innovation_num = _p1gene.innovation_num
                    avgene.mutation_num = (_p1gene.mutation_num + _p2gene.mutation_num) / 2.0

                    //If one is disabled, the corresponding gene in the offspring
                    //will likely be disabled
                    disable = false
                    if (_p1gene.enable == false || _p2gene.enable == false) {
                        exist_disable++
                        if (NeatRoutine.randfloat() < 0.75) {
                            disable = true
                            control_disable++
                        }
                    }
                    chosengene = avgene
                    j1++
                    j2++
                } else if (p1innov < p2innov) {
                    chosengene = _p1gene
                    j1++
                    if (!p1better) skip = true
                } else if (p2innov < p1innov) {
                    chosengene = _p2gene
                    j2++
                    if (p1better) skip = true
                }
            } // end chosen gene

            //
            //
            //Check to see if the chosengene conflicts with an already chosen gene
            //i.e. do they represent the same link
            //
            itr_newgenes = newgenes.iterator()
            while (itr_newgenes.hasNext()) {
                _curgene2 = itr_newgenes.next() as Gene?
                if (_curgene2!!.lnk!!.in_node.node_id == chosengene!!.lnk!!.in_node.node_id && _curgene2.lnk!!.out_node.node_id == chosengene.lnk!!.out_node.node_id && _curgene2.lnk!!.is_recurrent == chosengene.lnk!!.is_recurrent) {
                    skip = true
                    break
                }
                if (_curgene2.lnk!!.in_node.node_id == chosengene.lnk!!.out_node.node_id && _curgene2.lnk!!.out_node.node_id == chosengene.lnk!!.in_node.node_id && !_curgene2.lnk!!.is_recurrent
                        && !chosengene.lnk!!.is_recurrent) {
                    skip = true
                    break
                }
            }

            //
            //
            //
            if (!skip) {
                //Now add the chosengene to the baby
                //First, get the trait pointer
                val first_traitnum = (traits.first() as Trait).trait_id
                traitnum = if (chosengene!!.lnk!!.linktrait == null) first_traitnum else chosengene.lnk!!.linktrait!!.trait_id - first_traitnum

                //Next check for the nodes, add them if not in the baby Genome already
                inode = chosengene.lnk!!.in_node
                onode = chosengene.lnk!!.out_node

                //Check for inode in the newnodes list
                //

                //--------------------------------------------------------------------------------
                var found: Boolean
                if (inode.node_id < onode.node_id) {
                    //
                    // search the inode
                    //
                    found = false
                    for (ix in newnodes.indices) {
                        curnode = newnodes.elementAt(ix) as NNode
                        if (curnode!!.node_id == inode.node_id) {
                            found = true
                            break
                        }
                    }

                    // if exist , point to exitsting version
                    if (found) new_inode = curnode else {
                        nodetraitnum = if (inode.nodetrait == null) 0 else inode.nodetrait!!.trait_id - first_traitnum
                        newtrait = newtraits.elementAt(nodetraitnum) as Trait
                        new_inode = NNode(inode, newtrait)
                        //insert in newnodes list
                        node_insert(newnodes, new_inode)
                    }

                    //
                    // search the onode
                    //
                    found = false
                    for (ix in newnodes.indices) {
                        curnode = newnodes.elementAt(ix) as NNode
                        if (curnode!!.node_id == onode.node_id) {
                            found = true
                            break
                        }
                    }

                    // if exist , point to exitsting version
                    if (found) new_onode = curnode else {
                        nodetraitnum = if (onode.nodetrait == null) 0 else onode!!.nodetrait!!.trait_id - first_traitnum
                        newtrait = newtraits.elementAt(nodetraitnum) as Trait
                        new_onode = NNode(onode, newtrait)
                        //insert in newnodes list
                        node_insert(newnodes, new_onode)
                    }
                } // end block : inode.node_id < onode.node_id
                else {

                    //
                    // search the onode
                    //
                    found = false
                    for (ix in newnodes.indices) {
                        curnode = newnodes.elementAt(ix) as NNode
                        if (curnode!!.node_id == onode.node_id) {
                            found = true
                            break
                        }
                    }

                    // if exist , point to exitsting version
                    if (found) new_onode = curnode else {
                        nodetraitnum = if (onode.nodetrait == null) 0 else onode!!.nodetrait!!.trait_id - first_traitnum
                        newtrait = newtraits.elementAt(nodetraitnum) as Trait
                        new_onode = NNode(onode, newtrait)
                        //insert in newnodes list
                        node_insert(newnodes, new_onode)
                    }

                    //
                    // search the inode
                    //
                    found = false
                    for (ix in newnodes.indices) {
                        curnode = newnodes.elementAt(ix) as NNode
                        if (curnode!!.node_id == inode.node_id) {
                            found = true
                            break
                        }
                    }

                    // if exist , point to exitsting version
                    if (found) new_inode = curnode else {
                        nodetraitnum = if (inode.nodetrait == null) 0 else inode.nodetrait!!.trait_id - first_traitnum
                        newtrait = newtraits.elementAt(nodetraitnum) as Trait
                        new_inode = NNode(inode, newtrait)
                        //insert in newnodes list
                        node_insert(newnodes, new_inode)
                    }
                }

                //--------------------------------------------------------------------------------

                //Add the Gene
                newtrait = newtraits.elementAt(traitnum) as Trait
                newgene = Gene(chosengene, newtrait, new_inode!!, new_onode!!)
                if (disable) {
                    newgene.enable = false
                    disable = false
                }
                newgenes.add(newgene)
            }
        } // end block genome
        new_genome = Genome(genomeid, newtraits, newnodes, newgenes)
        return new_genome
    }

    private fun dummyNode(): NNode {
        return NNode(NeatConstant.INPUT, -1)
    }

    /**
     *
     */
    fun mate_singlepoint(g: Genome, genomeid: Int): Genome {
        val mask4 = " 0000"
        val fmt4 = DecimalFormat(mask4)
        var new_genome: Genome? = null
        var chosengene: Gene? = null
        var _trait1: Trait? = null
        var _trait2: Trait? = null
        var newtrait: Trait? = null
        var stopA = 0
        var stopB = 0
        var j: Int
        var j1: Int
        var j2: Int
        val control_addnode = 0
        val len_traits = traits.size
        val size1 = genes.size
        val size2 = g.genes.size
        var crosspoint = 0
        var len_genome = 0
        val len = 0
        val p1innov = 0.0
        val p2innov = 0.0
        var itr_newgenes: Iterator<*>
        var curnode: NNode? = null
        var inode: NNode? = null
        var onode: NNode? = null
        var new_inode: NNode? = null
        var new_onode: NNode? = null
        var newgene: Gene? = null
        val disable = false
        var traitnum = 0
        var nodetraitnum = 0
        var genomeA: MutableList<Gene>
        var genomeB: MutableList<Gene>
        var geneA: Gene? = null
        var geneB: Gene? = null
        var _curgene2: Gene? = null
        var genecounter = 0 //Ready to count to crosspoint
        var skip = false //Default to not skip a Gene
        val done_in = false
        val done_out = false
        val newtraits = mutableListOf<Trait>()
        j = 0
        while (j < len_traits) {
            _trait1 = traits.elementAt(j) as Trait
            _trait2 = g.traits.elementAt(j) as Trait
            newtrait = Trait(_trait1, _trait2)
            newtraits.add(newtrait)
            j++
        }

        //Set up the avgene
        val avgene = Gene(null as Trait?, 0.0, dummyNode(), dummyNode(), false, 0.0, 0.0)
        val newgenes = mutableListOf<Gene>()
        val newnodes = mutableListOf<NNode>()
        if (size1 < size2) {
            crosspoint = NeatRoutine.randint(0, size1 - 1)
            stopA = size1
            stopB = size2
            len_genome = size2
            genomeA = genes
            genomeB = g.genes
        } else {
            crosspoint = NeatRoutine.randint(0, size2 - 1)
            stopA = size2
            stopB = size1
            len_genome = size1
            genomeA = g.genes
            genomeB = genes
        }

        //System.out.print("\n crossing point is :"+crosspoint);
        genecounter = 0
        var doneA = false
        var doneB = false
        var done = false
        var v1 = 0.0
        var v2 = 0.0
        val vmax = 0.0
        var cellA = 0.0
        var cellB = 0.0
        j1 = 0
        j2 = 0
        j = 0

        //
        // compute what is the hight innovation
        //
        val last_innovB = (genomeB.elementAt(stopB - 1) as Gene).innovation_num
        var cross_innov = 0.0
        while (!done) {
            doneA = false
            doneB = false
            skip = false
            avgene.enable = true //Default to true
            if (j1 < stopA) {
                geneA = genomeA.elementAt(j1) as Gene
                v1 = geneA!!.innovation_num
                doneA = true
            }
            if (j2 < stopB) {
                geneB = genomeB.elementAt(j2) as Gene
                v2 = geneB!!.innovation_num
                doneB = true
            }
            if (doneA && doneB) {
                //
                if (v1 < v2) {
                    cellA = v1
                    cellB = 0.0
                    j1++
                } else if (v1 == v2) {
                    cellA = v1
                    cellB = v1
                    j1++
                    j2++
                } else {
                    cellA = 0.0
                    cellB = v2
                    j2++
                }
            } else {
                if (doneA && !doneB) {
                    cellA = v1
                    cellB = 0.0
                    j1++
                } else if (!doneA && doneB) {
                    cellA = 0.0
                    cellB = v2
                    j2++
                } else done = true
            }
            if (!done) {

                // -------------------------------------------------------------------------------
                //                        innovA = innovB
                // -------------------------------------------------------------------------------
                if (cellA == cellB) {
                    if (genecounter < crosspoint) {
                        chosengene = geneA
                        genecounter++
                    } else if (genecounter == crosspoint) {
                        if (NeatRoutine.randfloat() > 0.5) avgene.lnk!!.linktrait = geneA!!.lnk!!.linktrait else avgene.lnk!!.linktrait = geneB!!.lnk!!.linktrait

                        //WEIGHTS AVERAGED HERE
                        avgene.lnk!!.weight = (geneA!!.lnk!!.weight + geneB!!.lnk!!.weight) / 2.0
                        if (NeatRoutine.randfloat() > 0.5) avgene.lnk!!.in_node = geneA.lnk!!.in_node else avgene.lnk!!.in_node = geneB.lnk!!.in_node
                        if (NeatRoutine.randfloat() > 0.5) avgene.lnk!!.out_node = geneA.lnk!!.out_node else avgene.lnk!!.out_node = geneB.lnk!!.out_node
                        if (NeatRoutine.randfloat() > 0.5) avgene.lnk!!.is_recurrent = geneA.lnk!!.is_recurrent else avgene.lnk!!.is_recurrent = geneB.lnk!!.is_recurrent
                        avgene.innovation_num = geneA.innovation_num
                        avgene.mutation_num = (geneA.mutation_num + geneB.mutation_num) / 2.0

                        //If one is disabled, the corresponding gene in the offspring
                        //will likely be disabled
                        if (geneA.enable == false || geneB.enable == false) avgene.enable = false
                        chosengene = avgene
                        genecounter++
                        cross_innov = cellA
                    } else if (genecounter > crosspoint) {
                        chosengene = geneB
                        genecounter++
                    }
                } else if (cellA != 0.0 && cellB == 0.0) {
                    if (genecounter < crosspoint) {
                        chosengene = geneA //make geneA
                        genecounter++
                    } else if (genecounter == crosspoint) {
                        chosengene = geneA
                        genecounter++
                        cross_innov = cellA
                    } else if (genecounter > crosspoint) {
                        if (cross_innov > last_innovB) {
                            chosengene = geneA
                            genecounter++
                        } else {
                            skip = true
                        }
                    }
                } else {
                    if (cellA == 0.0 && cellB != 0.0) {
                        if (genecounter < crosspoint) {
                            skip = true //skip geneB
                        } else if (genecounter == crosspoint) {
                            skip = true //skip an illogic case
                        } else if (genecounter > crosspoint) {
                            if (cross_innov > last_innovB) {
                                chosengene = geneA //make geneA
                                genecounter++
                            } else {
                                chosengene = geneB //make geneB : this is a pure case o single crossing
                                genecounter++
                            }
                        }
                    }
                }
                itr_newgenes = newgenes.iterator()
                while (itr_newgenes.hasNext()) {
                    _curgene2 = itr_newgenes.next() as Gene?
                    if (_curgene2!!.lnk!!.in_node.node_id == chosengene!!.lnk!!.in_node.node_id && _curgene2.lnk!!.out_node.node_id == chosengene.lnk!!.out_node.node_id && _curgene2.lnk!!.is_recurrent == chosengene.lnk!!.is_recurrent) {
                        skip = true
                        break
                    }
                    if (_curgene2.lnk!!.in_node.node_id == chosengene.lnk!!.out_node.node_id && _curgene2.lnk!!.out_node.node_id == chosengene.lnk!!.in_node.node_id && !_curgene2.lnk!!.is_recurrent
                            && !chosengene.lnk!!.is_recurrent) {
                        skip = true
                        break
                    }
                } // and else for control of position in gennomeA/B
                if (!skip) {
                    //Now add the chosengene to the baby
                    //First, get the trait pointer
                    val first_traitnum = (traits.first() as Trait).trait_id
                    traitnum = if (chosengene!!.lnk!!.linktrait == null) first_traitnum else chosengene.lnk!!.linktrait!!.trait_id - first_traitnum

                    //Next check for the nodes, add them if not in the baby Genome already
                    inode = chosengene.lnk!!.in_node
                    onode = chosengene.lnk!!.out_node

                    //
                    //Check for inode, onode in the newnodes list
                    //
                    var found: Boolean
                    if (inode.node_id < onode.node_id) {
                        //
                        // search the inode
                        //
                        found = false
                        for (ix in newnodes.indices) {
                            curnode = newnodes.elementAt(ix) as NNode
                            if (curnode!!.node_id == inode.node_id) {
                                found = true
                                break
                            }
                        }
                        // if exist , point to exitsting version
                        if (found) new_inode = curnode else {
                            nodetraitnum = if (inode.nodetrait == null) 0 else inode.nodetrait!!.trait_id - first_traitnum
                            newtrait = newtraits.elementAt(nodetraitnum) as Trait
                            new_inode = NNode(inode, newtrait)
                            //insert in newnodes list
                            node_insert(newnodes, new_inode)
                        }

                        //
                        // search the onode
                        //
                        found = false
                        for (ix in newnodes.indices) {
                            curnode = newnodes.elementAt(ix) as NNode
                            if (curnode!!.node_id == onode.node_id) {
                                found = true
                                break
                            }
                        }
                        // if exist , point to exitsting version
                        if (found) new_onode = curnode else {
                            nodetraitnum = if (onode.nodetrait == null) 0 else onode!!.nodetrait!!.trait_id - first_traitnum
                            newtrait = newtraits.elementAt(nodetraitnum) as Trait
                            new_onode = NNode(onode, newtrait)
                            //insert in newnodes list
                            node_insert(newnodes, new_onode)
                        }
                    } // end block : inode.node_id < onode.node_id
                    else {
                        //
                        // search the onode
                        //
                        found = false
                        for (ix in newnodes.indices) {
                            curnode = newnodes.elementAt(ix) as NNode
                            if (curnode!!.node_id == onode.node_id) {
                                found = true
                                break
                            }
                        }
                        // if exist , point to exitsting version
                        if (found) new_onode = curnode else {
                            nodetraitnum = if (onode.nodetrait == null) 0 else onode!!.nodetrait!!.trait_id - first_traitnum
                            newtrait = newtraits.elementAt(nodetraitnum) as Trait
                            new_onode = NNode(onode, newtrait)
                            //insert in newnodes list
                            node_insert(newnodes, new_onode)
                        }
                        //
                        // search the inode
                        //
                        found = false
                        for (ix in newnodes.indices) {
                            curnode = newnodes.elementAt(ix) as NNode
                            if (curnode!!.node_id == inode.node_id) {
                                found = true
                                break
                            }
                        }

                        // if exist , point to exitsting version
                        if (found) new_inode = curnode else {
                            nodetraitnum = if (inode.nodetrait == null) 0 else inode.nodetrait!!.trait_id - first_traitnum
                            newtrait = newtraits.elementAt(nodetraitnum) as Trait
                            new_inode = NNode(inode, newtrait)

                            //insert in newnodes list
                            node_insert(newnodes, new_inode)
                        }
                    }

                    //Add the Gene
                    newtrait = newtraits.elementAt(traitnum) as Trait
                    newgene = Gene(chosengene, newtrait, new_inode!!, new_onode!!)
                    newgenes.add(newgene)
                } // end of block gene creation if !skip
            }
            j++
        }
        new_genome = Genome(genomeid, newtraits, newnodes, newgenes)
        //
        // search the existence of output node
        // if no dump
        //
        return new_genome
    }

    fun mutate_gene_reenable() {
        val itr_gene: Iterator<*>
        itr_gene = genes.iterator()
        var _gene: Gene? = null
        while (itr_gene.hasNext()) {
            _gene = itr_gene.next() as Gene?
            if (!_gene!!.enable) {
                _gene.enable = true
                break
            }
        }
    }

    /**
     * This chooses a random gene, extracts the link from it,
     * and repoints the link to a random trait
     */
    fun mutate_link_trait(times: Int) {
        var traitnum: Int
        var genenum: Int
        var count: Int
        var loop: Int
        var _gene: Gene? = null
        var _trait: Trait? = null
        loop = 1
        while (loop <= times) {


            //Choose a random traitnum
            traitnum = NeatRoutine.randint(0, traits.size - 1)
            //Choose a random linknum
            genenum = NeatRoutine.randint(0, genes.size - 1)
            //set the link to point to the new trait
            _gene = genes.elementAt(genenum) as Gene
            _trait = traits.elementAt(traitnum) as Trait
            _gene!!.lnk!!.linktrait = _trait
            loop++
        }
    }

    /**
     * This chooses a random node
     * and repoints the node to a random trait
     */
    fun mutate_node_trait(times: Int) {
        var traitnum: Int
        var nodenum: Int
        var count: Int
        var loop: Int
        var _node: NNode? = null
        var _trait: Trait? = null
        loop = 1
        while (loop <= times) {


            //Choose a random traitnum
            traitnum = NeatRoutine.randint(0, traits.size - 1)
            //Choose a random nodenum
            nodenum = NeatRoutine.randint(0, nodes.size - 1)
            //set the link to point to the new trait
            _node = nodes.elementAt(nodenum) as NNode
            _trait = traits.elementAt(traitnum) as Trait
            _node!!.nodetrait = traits.elementAt(traitnum) as Trait
            loop++
        }
    }

    /**
     * Insert the method's description here.
     * Creation date: (24/01/2002 9.03.36)
     */
    fun mutate_random_trait() {
        val traitnum: Int

        //Choose a random traitnum
        traitnum = NeatRoutine.randint(0, traits.size - 1)
        //Retrieve the trait and mutate it
        val _trait = traits.elementAt(traitnum) as Trait
        _trait.mutate()

        //TRACK INNOVATION? (future possibility)
    }

    /**
     * Insert the method's description here.
     * Creation date: (24/01/2002 9.03.36)
     */
    //
    // Toggle genes from enable on to enable off or
    //   vice versa.  Do it times times.
    //
    fun mutate_toggle_enable(times: Int) {
        var genenum: Int
        var count: Int
        var genecount: Int
        var _gene: Gene? = null
        var _jgene: Gene? = null
        val len_gene = genes.size
        var done = false
        count = 1
        while (count <= times) {


            //Choose a random genenum
            genenum = NeatRoutine.randint(0, genes.size - 1)
            //find the gene
            _gene = genes.elementAt(genenum) as Gene
            //Toggle the enable on this gene
            if (_gene!!.enable) {
                //We need to make sure that another gene connects out of the in-node
                //Because if not a section of network will break off and become isolated
                done = false
                for (j in 0 until len_gene) {
                    _jgene = genes.elementAt(j) as Gene
                    if (_gene.lnk!!.in_node === _jgene!!.lnk!!.in_node
                            && _jgene!!.enable
                            && _jgene.innovation_num != _gene.innovation_num) {
                        done = true
                        break
                    }
                }
                //Disable the gene if it's safe to do so
                if (done) _gene.enable = false
            } else _gene.enable = true
            count++
        }
    }

    fun node_insert(nlist: MutableList<NNode>, n: NNode?) {
        var j: Int
        val id = n!!.node_id
        val sz = nlist.size
        j = 0
        while (j < sz) {
            if ((nlist.elementAt(j) as NNode).node_id >= id) break
            j++
        }
        nlist.add(j, n)
    }

    fun mutate_add_link(pop: Population, tries: Int): Boolean {
        var done = false
        var do_recur = false
        var loop_recur = false
        val recur_flag = false
        var found = false
        var bypass = false
        var recurflag = false
        var first_nonsensor: Int
        var trycount = 0
        val thresh = nodes.size * nodes.size
        val count = 0
        var nodenum1: Int
        var nodenum2: Int
        var lcount: Long
        var traitnum: Int
        var new_weight: Double
        var thenode1: NNode = dummyNode()
        var thenode2: NNode = dummyNode()
        var new_gene: Gene? = null
        var _gene: Gene? = null
        val itr_gene: Iterator<*>? = null
        var itr_node: Iterator<*>? = null
        var itr_innovation: Iterator<*>? = null


        //Make attempts to find an unconnected pair
        trycount = 0

        //Decide whether to make this recurrent
        do_recur = if (NeatRoutine.randfloat() < Neat.p_recur_only_prob) true else false

        //Find the first non-sensor so that the to-node won't look at sensors as
        //possible destinations
        itr_node = nodes.iterator()
        first_nonsensor = 0
        while (itr_node.hasNext()) {
            thenode1 = itr_node.next()
            if (thenode1!!.type != NeatConstant.SENSOR) break
            first_nonsensor++
        }
        found = false
        while (trycount < tries) {
            //
            // recurrency case .........
            //
            if (do_recur) {
                //
                // at this point :
                //50% of prob to decide a loop recurrency( node X to node X)
                // 50% a normal recurrency ( node X to node Y)
                loop_recur = if (NeatRoutine.randfloat() > 0.5) true else false
                if (loop_recur) {
                    nodenum1 = NeatRoutine.randint(first_nonsensor, nodes.size - 1)
                    nodenum2 = nodenum1
                } else {
                    nodenum1 = NeatRoutine.randint(0, nodes.size - 1)
                    nodenum2 = NeatRoutine.randint(first_nonsensor, nodes.size - 1)
                }
            } else {
                nodenum1 = NeatRoutine.randint(0, nodes.size - 1)
                nodenum2 = NeatRoutine.randint(first_nonsensor, nodes.size - 1)
            }

            //
            // now point to object's nodes
            //
            thenode1 = nodes.elementAt(nodenum1) as NNode
            thenode2 = nodes.elementAt(nodenum2) as NNode

            //
            // verify if the possible new gene already EXIST
            //
            bypass = false
            for (j in genes.indices) {
                _gene = genes.elementAt(j) as Gene
                if (thenode2!!.type == NeatConstant.SENSOR) {
                    bypass = true
                    break
                }
                if (_gene!!.lnk!!.in_node === thenode1 && _gene!!.lnk!!.out_node === thenode2 && _gene!!.lnk!!.is_recurrent
                        && do_recur) {
                    bypass = true
                    break
                }
                if (_gene!!.lnk!!.in_node === thenode1 && _gene!!.lnk!!.out_node === thenode2 && !_gene!!.lnk!!.is_recurrent
                        && !do_recur) {
                    bypass = true
                    break
                }
            }
            if (!bypass) {
                phenotype!!.status = 0
                recurflag = phenotype!!.has_a_path(thenode1!!.analogue!!, thenode2!!.analogue!!, 0, thresh)
                if (phenotype!!.status == 8) {
                    println(
                            "\n  network.mutate_add_link : LOOP DETECTED DURING A RECURRENCY CHECK")
                    return false
                }
                if (!recurflag && do_recur || recurflag && !do_recur) trycount++ else {
                    trycount = tries
                    found = true
                }
            } // end block bypass
            else trycount++
        } // end block trycount
        if (found) {

            //Check to see if this innovation already occured in the population
            itr_innovation = pop.innovations.iterator()
            done = false
            while (!done) {
                if (!itr_innovation.hasNext()) {

                    //If the phenotype does not exist, exit on false,print error
                    //Note: This should never happen- if it does there is a bug
                    if (phenotype == null) {
                        print("ERROR: Attempt to add link to genome with no phenotype")
                        return false
                    }

                    //Choose a random trait
                    traitnum = NeatRoutine.randint(0, traits.size - 1)

                    //Choose the new weight
                    //newweight=(gaussrand())/1.5;  //Could use a gaussian
                    new_weight = NeatRoutine.randposneg() * NeatRoutine.randfloat() * 10.0

                    // read from population current innovation value

                    // read curr innovation with postincrement
                    val curr_innov = pop.curr_innov_num_and_increment
                    //Create the new gene
                    new_gene = Gene(traits.elementAt(traitnum) as Trait, new_weight, thenode1, thenode2, do_recur, curr_innov, new_weight)
                    //Add the innovation
                    pop.innovations.add(Innovation(thenode1!!.node_id, thenode2!!.node_id, curr_innov, new_weight, traitnum))
                    done = true
                } else {
                    val _innov = itr_innovation.next()
                    if (_innov.innovation_type == NeatConstant.NEWLINK
                            && _innov.node_in_id == thenode1!!.node_id
                            && _innov.node_out_id == thenode2!!.node_id
                            && _innov.recur_flag == do_recur) {
                        new_gene = Gene(traits.elementAt(_innov.new_traitnum) as Trait, _innov.new_weight, thenode1, thenode2, do_recur, _innov.innovation_num1, 0.0)
                        done = true
                    }
                }
            }
            genes.add(new_gene!!)
            return true
        }
        return false
    }

    fun mutate_add_node(pop: Population): Boolean {
        var itr_gene: Iterator<*>
        var _gene: Gene? = null
        var thelink: Link? = null
        var oldweight = 0.0
        var newgene1: Gene? = null
        var newgene2: Gene? = null
        var in_node: NNode? = null
        var out_node: NNode? = null
        var new_node: NNode? = null
        val itr_innovation: Iterator<*>
        var traitptr: Trait? = null
        var j: Int
        var genenum = 0
        var trycount = 0
        var found = false
        val bypass = false
        val step1 = true
        var step2 = false
        var gene_innov1: Double
        var gene_innov2: Double
        if (genes.size < 15) {
            step2 = false
            j = 0
            while (j < genes.size) {
                _gene = genes.elementAt(j) as Gene
                if (_gene!!.enable && _gene.lnk!!.in_node.gen_node_label != NeatConstant.BIAS) break
                j++
            }
            while (j < genes.size) {
                _gene = genes.elementAt(j) as Gene
                if (NeatRoutine.randfloat() >= 0.3
                        && _gene!!.lnk!!.in_node.gen_node_label != NeatConstant.BIAS) {
                    step2 = true
                    break
                }
                j++
            }
            if (step2 && _gene!!.enable) {
                found = true
            }
        } else {
            while (trycount < 20 && !found) {
                //Pure random splittingNeatRoutine.randint
                genenum = NeatRoutine.randint(0, genes.size - 1)
                _gene = genes.elementAt(genenum) as Gene
                if (_gene!!.enable && _gene.lnk!!.in_node.gen_node_label != NeatConstant.BIAS) found = true
                ++trycount
            }
        }
        if (!found) return false
        _gene!!.enable = false

        //Extract the link
        thelink = _gene.lnk
        //Extract the weight;
        oldweight = thelink!!.weight
        //Get the old link's trait
        traitptr = thelink.linktrait

        //Extract the nodes
        in_node = thelink.in_node
        out_node = thelink.out_node
        var done = false
        itr_innovation = pop.innovations.iterator()
        while (!done) {
            //Check to see if this innovation already occured in the population
            if (!itr_innovation.hasNext()) {

                //The innovation is totally novel
                //Create the new Genes
                //Create the new NNode
                //By convention, it will point to the first trait
                // get the current node id with postincrement
                val curnode_id = pop.cur_node_id_and_increment

                // pass this current nodeid to newnode and create the new node
                new_node = NNode(NeatConstant.NEURON, curnode_id, NeatConstant.HIDDEN)
                new_node.nodetrait = traits.first() as Trait

                // get the current gene inovation with post increment
                gene_innov1 = pop.curr_innov_num_and_increment

                // create gene with the current gene inovation
                newgene1 = Gene(traitptr, 1.0, in_node, new_node, thelink.is_recurrent, gene_innov1, 0.0)

                // re-read the current innovation with increment
                gene_innov2 = pop.curr_innov_num_and_increment

                // create the second gene with this innovation incremented
                newgene2 = Gene(traitptr, oldweight, new_node, out_node, false, gene_innov2, 0.0)
                pop.innovations.add(Innovation(in_node.node_id, out_node.node_id, gene_innov1, gene_innov2, new_node.node_id, _gene.innovation_num))
                done = true
            } else {
                val _innov = itr_innovation.next()
                if (_innov.innovation_type == NeatConstant.NEWNODE
                        && _innov.node_in_id == in_node.node_id
                        && _innov.node_out_id == out_node.node_id
                        && _innov.old_innov_num == _gene.innovation_num) {
                    // Create the new Genes
                    // pass this current nodeid to newnode
                    new_node = NNode(NeatConstant.NEURON, _innov.newnode_id, NeatConstant.HIDDEN)
                    new_node.nodetrait = traits.first() as Trait
                    newgene1 = Gene(traitptr, 1.0, in_node, new_node, thelink.is_recurrent, _innov.innovation_num1, 0.0)
                    newgene2 = Gene(traitptr, oldweight, new_node, out_node, false, _innov.innovation_num2, 0.0)
                    done = true
                }
            }
        }

        //Now add the new NNode and new Genes to the Genome
        genes.add(newgene1!!)
        genes.add(newgene2!!)
        node_insert(nodes, new_node)
        return true
    }

    /**
     * Creation of a new random genome with :
     * new_id   = numerical identification of genome
     * i   = number of input nodes
     * o   = number of output nodes
     * n   = number of hidden nodes
     * nmax   = number max of node
     * this number must be >= (i + n + o)
     * r   = the network can have a nodes recurrent ?
     * linkprob = probability of a link from nodes ( must be in interval  ]0,1[);
     */
    constructor(new_id: Int, i: Int, o: Int, n: Int, nmax: Int, r: Boolean, linkprob: Double) {
        var linkprob = linkprob
        var totalnodes = 0
        var matrixdim = 0
        var maxnode = 0
        var first_output = 0
        var count = 0
        var ccount = 0
        var innov_number = 0
        var col = 0
        var row = 0
        var fnd = 0
        val pointer = 0
        var gene_number = 0
        var flag_recurrent = false
        var create_gene = false
        var new_weight = 0.0
        var newtrait: Trait? = null
        var newnode: NNode = dummyNode()
        var in_node: NNode = dummyNode()
        var out_node: NNode = dummyNode()
        var newgene: Gene? = null
        notes = null
        var itr_node: Iterator<*>


        //
        //    i i i n n n n n n n n n n n n n n n n . . . . . . . . o o o o
        //    |                                   |                 ^     |
        //    |<----------- maxnode ------------->|                 |     |
        //    |                                                     |     |
        //    |<-----------------------total nodes -----------------|---->|
        //                                                          |
        //                                                          |
        //     first output ----------------------------------------+
        //
        //
        totalnodes = i + o + nmax
        traits = mutableListOf()
        nodes = mutableListOf()
        genes = mutableListOf()
        matrixdim = totalnodes * totalnodes
        val cm = BooleanArray(matrixdim) //Dimension the connection matrix
        var cmp: BooleanArray
        maxnode = i + n
        first_output = totalnodes - o + 1

        //Assign the id
        genome_id = new_id

        //Create a dummy trait (this is for future expansion of the system)
        newtrait = Trait(1, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0)
        traits.add(newtrait)

        //Build the input nodes
        count = 1
        while (count <= i) {
            newnode = if (count < i) NNode(NeatConstant.SENSOR, count, NeatConstant.INPUT) else NNode(NeatConstant.SENSOR, count, NeatConstant.BIAS)
            newnode.nodetrait = newtrait
            //Add the node to the list of nodes
            nodes.add(newnode)
            count++
        }

        //Build the hidden nodes
        count = i + 1
        while (count <= i + n) {
            newnode = NNode(NeatConstant.NEURON, count, NeatConstant.HIDDEN)
            newnode.nodetrait = newtrait

            //Add the node to the list of nodes
            nodes.add(newnode)
            count++
        }

        //Build the output nodes
        count = first_output
        while (count <= totalnodes) {
            newnode = NNode(NeatConstant.NEURON, count, NeatConstant.OUTPUT)
            newnode.nodetrait = newtrait

            //Add the node to the list of nodes
            nodes.add(newnode)
            count++
        }
        var done = false
        var rc1 = false
        var rc2 = false
        val rc3 = false
        val min_required = i * o
        var forced_probability = 0.5
        var abort = 0
        while (!done) {
            abort++
            if (abort >= 20) {
                //	   		if (abort == 10)
                //		    	System.out.print("\n ALERT  force new probability from 0.5 to 1 step .01");
                linkprob = forced_probability
                forced_probability += .01
            }
            if (abort >= 700) {
                print("\n SEVERE ERROR in genome random creation costructor : genome has not created")
                System.exit(12)
            }


            //
            //creation of connections matrix
            //Step through the connection matrix, randomly assigning bits
            //
            cmp = cm
            ccount = 0
            count = 0
            while (count < matrixdim) {
                if (NeatRoutine.randfloat() < linkprob) {
                    ccount++
                    cmp[count] = true
                } else cmp[count] = false
                count++
            }


            //Connect the nodes
            innov_number = 0 //counter for labelling the innov_num  of genes
            gene_number = 0 //counter gene created

            //Step through the connection matrix, creating connection genes
            cmp = cm
            col = 1
            while (col <= totalnodes) {
                row = 1
                while (row <= totalnodes) {
                    if (cmp[innov_number] && col > i
                            && (col <= maxnode || col >= first_output)
                            && (row <= maxnode || row >= first_output)) {
                        //If it isn't recurrent, create the connection no matter what
                        create_gene = true
                        if (col > row) flag_recurrent = false else {
                            if (!r) create_gene = false
                            flag_recurrent = true
                        }
                        if (create_gene) {
                            itr_node = nodes.iterator() //Retrieve the in_node , out_node
                            fnd = 0
                            while (itr_node.hasNext() && fnd < 2) {
                                val _node = itr_node.next() as NNode
                                if (_node.node_id == row) {
                                    fnd++
                                    in_node = _node
                                }
                                if (_node.node_id == col) {
                                    fnd++
                                    out_node = _node
                                }
                            }
                            //Create the gene + link
                            new_weight = NeatRoutine.randposneg() * NeatRoutine.randfloat()
                            newgene = Gene(newtrait, new_weight, in_node, out_node, flag_recurrent, innov_number.toDouble(), new_weight)
                            //Add the gene to the genome
                            genes.add(newgene)
                        }
                    } // end condition for a correct link in genome
                    innov_number++
                    row++
                }
                col++
            }
            rc1 = verify()

            //		System.out.print("\n      -> +rc1 = "+rc1);
            if (rc1) {
                val net = genesis(genome_id)
                rc2 = net.is_minimal()

                //	 		System.out.print("\n         -> +rc2 = "+rc2);
                if (rc2) {
                    val lx = net.max_depth()
                    val dx = net.is_stabilized(lx)


                    //				System.out.print("\n        lx = " + lx);
                    //				System.out.print(", dx = " + dx);
                    if (dx == lx && !r || lx > 0 && r && dx == 0) done = true
                }
                net.genotype = null
                phenotype = null
            }
            if (!done) genes.clear()
            //			else
//			   System.out.print("\n * CREATION Genome #"+genome_id+" okay");
        }
    }

    constructor(id: Int, xFile: IOseq) {
        var st: StringTokenizer
        var curword: String
        var xline: String?
        var done = false
        //   	notes = null;
        genome_id = id

        //	System.out.print("\n genome id current is "+ genome_id);
        traits = mutableListOf()
        nodes = mutableListOf()
        genes = mutableListOf()
        while (!done) {
            xline = xFile.IOseqRead()
            st = StringTokenizer(xline)
            curword = st.nextToken()
            if (curword.equals("genomeend", ignoreCase = true)) {
                curword = st.nextToken()
                if (curword.toInt() != genome_id) println(" *ERROR* id mismatch in genome")
                done = true
            } else if (curword == "/*") {
                curword = st.nextToken()
                while (curword != "*/") curword = st.nextToken()
            } else if (curword == "trait") {
                var newtrait: Trait
                newtrait = Trait(xline)
                traits.add(newtrait)
            } else if (curword == "node") {
                var newnode: NNode
                newnode = NNode(xline, traits)
                nodes.add(newnode)
            } else if (curword == "gene") {
                var newgene: Gene
                newgene = Gene(xline, traits, nodes)
                genes.add(newgene)
            }
        }
    }

    fun print_to_file(xFile: IOseq) {
        //
        // write to file genome in native format (for re-read)
        //
        var riga = "genomestart  $genome_id"
        xFile.IOseqWrite(riga)
        var itr_trait: Iterator<*> = traits.iterator()
        itr_trait = traits.iterator()
        while (itr_trait.hasNext()) {
            val _trait = itr_trait.next() as Trait
            _trait.print_to_file(xFile)
        }
        var itr_node: Iterator<*> = nodes.iterator()
        itr_node = nodes.iterator()
        while (itr_node.hasNext()) {
            val _node = itr_node.next() as NNode
            _node.print_to_file(xFile)
        }
        var itr_gene: Iterator<*> = genes.iterator()
        itr_gene = genes.iterator()
        while (itr_gene.hasNext()) {
            val _gene = itr_gene.next() as Gene
            _gene.print_to_file(xFile)
        }
        riga = "genomeend $genome_id"
        xFile.IOseqWrite(riga)
    }

    /**
     *
     */
    fun View_mate_singlepoint(g: Genome, genomeid: Int) {
        val mask4 = " 0000"
        val fmt4 = DecimalFormat(mask4)
        val new_genome: Genome? = null
        var stopA = 0
        var stopB = 0
        var j: Int
        var j1: Int
        var j2: Int
        val size1 = genes.size
        val size2 = g.genes.size
        var crosspoint = 0
        val genomeA: List<Gene>
        val genomeB: List<Gene>
        var genecounter = 0 //Ready to count to crosspoint
        if (size1 < size2) {
            stopA = size1
            stopB = size2
            genomeA = genes
            genomeB = g.genes
        } else {
            stopA = size2
            stopB = size1
            genomeA = g.genes
            genomeB = genes
        }
        val v3 = Array(size2 * 2) { DoubleArray(2) }
        val vr = DoubleArray(size2 * 2)
        crosspoint = 0
        while (crosspoint < stopA) {
            genecounter = 0
            var doneA = false
            var doneB = false
            var done = false
            var v1 = 0.0
            var v2 = 0.0
            val vmax = 0.0
            j1 = 0
            j2 = 0
            j = 0
            var cross_innov = 0.0
            //
            // compute what is the hight innovation
            //
            val last_innovB = (genomeB.elementAt(stopB - 1) as Gene).innovation_num
            while (!done) {
                doneA = false
                doneB = false
                if (j1 < stopA) {
                    v1 = (genomeA.elementAt(j1) as Gene).innovation_num
                    doneA = true
                }
                if (j2 < stopB) {
                    v2 = (genomeB.elementAt(j2) as Gene).innovation_num
                    doneB = true
                }
                if (doneA && doneB) {
                    //
                    if (v1 < v2) {
                        v3[j][0] = v1
                        v3[j][1] = 0.0
                        j1++
                    } else if (v1 == v2) {
                        v3[j][0] = v1
                        v3[j][1] = v1
                        j1++
                        j2++
                    } else {
                        v3[j][0] = 0.0
                        v3[j][1] = v2
                        j2++
                    }
                } else {
                    if (doneA && !doneB) {
                        v3[j][0] = v1
                        v3[j][1] = 0.0
                        j1++
                    } else if (!doneA && doneB) {
                        v3[j][0] = 0.0
                        v3[j][1] = v2
                        j2++
                    } else done = true
                }
                if (!done) {


                    // -------------------------------------------------------------------------------
                    //                        innovA = innovB
                    // -------------------------------------------------------------------------------
                    if (v3[j][0] == v3[j][1]) {
                        if (genecounter < crosspoint) {
                            vr[j] = 1.0
                            genecounter++
                        } else if (genecounter == crosspoint) {
                            vr[j] = 3.0
                            genecounter++
                            cross_innov = v3[j][0]
                        } else if (genecounter > crosspoint) {
                            vr[j] = 2.0
                            genecounter++
                        }
                    } else if (v3[j][0] != 0.0 && v3[j][1] == 0.0) {
                        if (genecounter < crosspoint) {
                            vr[j] = 1.0 //  v3[j][0];
                            genecounter++
                        } else if (genecounter == crosspoint) {
                            vr[j] = 1.0 // v3[j][1])
                            genecounter++
                            cross_innov = v3[j][0]
                        } else if (genecounter > crosspoint) {
                            if (cross_innov > last_innovB) {
                                vr[j] = 1.0
                                genecounter++
                            }
                        }
                    } else if (v3[j][0] == 0.0 && v3[j][1] != 0.0) {
                        if (genecounter < crosspoint) {
                            vr[j] = 0.0 //  skip v3[j][0];
                        } else if (genecounter == crosspoint) {
                            vr[j] = 0.0 // skip
                        } else if (genecounter > crosspoint) {
                            if (cross_innov > last_innovB) {
                                vr[j] = 1.0 // v3[j][1];
                                genecounter++
                            } else {
                                vr[j] = 2.0
                                genecounter++
                            }
                        }
                    }
                }
                j++
            }
            val len_max = --j

            //
            // only for debug  : view innov's genomeA,B
            //
            print("\n\n CROSSING SINGLE at index $crosspoint")
            print("\n -- index -- ")
            var column = 0
            j2 = 0
            while (j2 < len_max) {
                if (v3[j2][0] > 0.0) print(fmt4.format(column++.toLong())) else print("     ")
                j2++
            }
            print("\n ----------- ")
            j2 = 0
            while (j2 < len_max) {
                print("-----")
                j2++
            }
            j1 = 0
            while (j1 < 2) {
                print("\n Genome  [$j1] ")
                j2 = 0
                while (j2 < len_max) {
                    print(fmt4.format(v3[j2][j1].toLong()))
                    j2++
                }
                j1++
            }
            print("\n newgene [X] ")
            j2 = 0
            while (j2 < len_max) {
                if (vr[j2] == 1.0) print("  AA ") else if (vr[j2] == 2.0) print("  BB ") else if (vr[j2] == 3.0) print("  XX ") else if (vr[j2] == 4.0) print("  MM ") else if (vr[j2] == 0.0) print("  -- ")
                j2++
            }
            print("\n")
            crosspoint++
        }
    }

    fun print_to_filename(xNameFile: String?, descr: String) {
        //
        // write to file genome in native format (for re-read)
        //
        val xFile: IOseq
        xFile = IOseq(xNameFile)
        xFile.IOseqOpenW(false)
        try {
            xFile.IOseqWrite(descr)
            print_to_file(xFile)
        } catch (e: Throwable) {
            System.err.println(e)
        }
        xFile.IOseqCloseW()
    }
}